
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Library &#8212; Tutorial: Creating an LLVM Toolchain for the Cpu0 Architecture</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/haiku.css" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="LLDB" href="lldb.html" />
    <link rel="prev" title="Optimization" href="opt.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>Tutorial: Creating an LLVM Toolchain for the Cpu0 Architecture</span></a></h1>
        <h2 class="heading"><span>Library</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="opt.html">Optimization</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="lldb.html">LLDB</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <section id="library">
<span id="sec-lib"></span><h1>Library<a class="headerlink" href="#library" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#c-library-newlib" id="id16">C Library (Newlib)</a></p></li>
<li><p><a class="reference internal" href="#compiler-rt" id="id17">Compiler-rt</a></p></li>
<li><p><a class="reference internal" href="#software-float-point-support" id="id18">Software Float Point Support</a></p></li>
</ul>
</div>
<p>Since Cpu0 has not hardware float point instructions, it needs soft float point
library to finish the floating point operation. LLVM compiler-rt project include
software floating point library implementation <a class="reference internal" href="#lib-empty"><span class="std std-numref">Fig. 6</span></a> , so we choose it as the
implementation.</p>
<p>Since compiler-rt uses unix/linux rootfs structure, we fill the gap by add few
empty include-files in exlbt/include.</p>
<figure class="align-default" id="id12">
<span id="lib-empty"></span><img alt="_images/empty.png" src="_images/empty.png" />
<figcaption>
<p><span class="caption-number">Fig. 6 </span><span class="caption-text">compiler-rt/lib/builtins’ software float library</span><a class="headerlink" href="#id12" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<div class="graphviz"><img src="_images/graphviz-27ca1dabd6b60df91c84b556090fa1e8f64984d7.png" alt="// dot -Tpng lib.gv -o lib.png
digraph G {
  rankdir=LR;

  node [shape=&quot;&quot;,style=filled,fillcolor=lightyellow]; lib [label=&quot;lib (libm/soft-float/\nscanf/printf)&quot;];
  node [shape=&quot;&quot;,style=solid,color=black];
  &quot;User program&quot; -&gt; &quot;clang/llc&quot; [ label = &quot;c/c++&quot; ];
  lib -&gt; &quot;clang/llc&quot; [ label = &quot;c&quot; ];
  &quot;clang/llc&quot; -&gt; lld [ label = &quot;obj&quot; ];
}" class="graphviz" /></div>
<table class="docutils align-default" id="id13">
<caption><span class="caption-number">Table 2 </span><span class="caption-text">lldb dependences</span><a class="headerlink" href="#id13" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 29%" />
<col style="width: 71%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>functions</p></th>
<th class="head"><p>depend on</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>scanf</p></td>
<td><p>newlib/libc</p></td>
</tr>
<tr class="row-odd"><td><p>printf</p></td>
<td><p>sanitizter_printf.c of compiler-rt</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default" id="id14">
<caption><span class="caption-number">Table 3 </span><span class="caption-text">sanitizer_printf.c of compiler-rt dependences</span><a class="headerlink" href="#id14" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 43%" />
<col style="width: 57%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>functions</p></th>
<th class="head"><p>depend on</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>sanitizter_printf.c</p></td>
<td><p>builtins of compiler-rt</p></td>
</tr>
</tbody>
</table>
<section id="c-library-newlib">
<h2><a class="toc-backref" href="#id16">C Library (Newlib)</a><a class="headerlink" href="#c-library-newlib" title="Permalink to this headline">¶</a></h2>
<p>Newlib is a C library for bare metal platform.
Two libraries in newlib are libc and libm. Libc is for functions of
IO, file and string supported while libm is for mathematical functions.
Web of newlib is here <a class="footnote-reference brackets" href="#newlib" id="id1">1</a> and newlib/libm here <a class="footnote-reference brackets" href="#newlib-libm" id="id2">2</a> .
Since the next section compiler-rt/builtins depends on libm, please running
the following bash script is for installing and building newlib for
Cpu0.</p>
<p class="rubric">lbt/exlbt/newlib-cpu0.sh</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>#!/usr/bin/env bash

# change this dir for newlib-cygwin
NEWLIB_PARENT_DIR=$HOME/git

NEWLIB_DIR=$NEWLIB_PARENT_DIR/newlib-cygwin
CURR_DIR=`pwd`
CC=$HOME/llvm/test/build/bin/clang
CFLAGS=&quot;-target cpu0el-unknown-linux-gnu -static -fintegrated-as -Wno-error=implicit-function-declaration&quot;
AS=&quot;$HOME/llvm/test/build/bin/clang -static -fintegrated-as -c&quot;
AR=&quot;$HOME/llvm/test/build/bin/llvm-ar&quot;
RANLIB=&quot;$HOME/llvm/test/build/bin/llvm-ranlib&quot;
READELF=&quot;$HOME/llvm/test/build/bin/llvm-readelf&quot;

install_newlib() {
  pushd $NEWLIB_PARENT_DIR
  git clone git://sourceware.org/git/newlib-cygwin.git
  cd newlib-cygwin
  git checkout dcb25665be227fb5a05497b7178a3d5df88050ec
  cp $CURR_DIR/newlib.patch .
  git apply newlib.patch
  cp -rf $CURR_DIR/newlib-cygwin/newlib/libc/machine/cpu0 newlib/libc/machine/. 
  popd
}

build_cpu0() {
  rm -rf build-$CPU-$ENDIAN
  mkdir build-$CPU-$ENDIAN
  cd build-$CPU-$ENDIAN
  CFLAGS=&quot;-target cpu0$ENDIAN-unknown-linux-gnu -mcpu=$CPU -static -fintegrated-as -Wno-error=implicit-function-declaration&quot;
  CC=$CC CFLAGS=$CFLAGS AS=$AS AR=$AR RANLIB=$RANLIB READELF=$READELF ../newlib/configure --host=cpu0
  make
  cd ..
}

build_newlib() {
  pushd $NEWLIB_DIR
  CPU=cpu032I
  ENDIAN=eb
  build_cpu0;
  CPU=cpu032I
  ENDIAN=el
  build_cpu0;
  CPU=cpu032II
  ENDIAN=eb
  build_cpu0;
  CPU=cpu032II
  ENDIAN=el
  build_cpu0;
  popd
}

#install_newlib;
build_newlib;
</pre></div>
</div>
<p class="rubric">lbt/exlbt/newlib.patch</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>diff --git a/config.sub b/config.sub
index 63c1f1c8b..575e8d9d7 100755
--- a/config.sub
+++ b/config.sub
@@ -1177,6 +1177,7 @@ case $cpu-$vendor in
 			| d10v | d30v | dlx | dsp16xx \
 			| e2k | elxsi | epiphany \
 			| f30[01] | f700 | fido | fr30 | frv | ft32 | fx80 \
+                        | cpu0 \
 			| h8300 | h8500 \
 			| hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \
 			| hexagon \
diff --git a/newlib/configure.host b/newlib/configure.host
index ca6b46f03..7bbf46f25 100644
--- a/newlib/configure.host
+++ b/newlib/configure.host
@@ -176,6 +176,10 @@ case &quot;${host_cpu}&quot; in
   fr30)
 	machine_dir=fr30
 	;;
+  cpu0)
+	machine_dir=cpu0
+	newlib_cflags=&quot;${newlib_cflags} -DCOMPACT_CTYPE&quot;
+	;;
   frv)
 	machine_dir=frv
         ;;
@@ -751,6 +755,9 @@ newlib_cflags=&quot;${newlib_cflags} -DCLOCK_PROVIDED -DMALLOC_PROVIDED -DEXIT_PROVID
   fr30-*-*)
 	syscall_dir=syscalls
 	;;
+  cpu0-*)
+	syscall_dir=syscalls
+	;;
   frv-*-*)
         syscall_dir=syscalls
 	default_newlib_io_long_long=&quot;yes&quot;
diff --git a/newlib/libc/include/machine/ieeefp.h b/newlib/libc/include/machine/ieeefp.h
index 3c1f41e03..1e79a6b26 100644
--- a/newlib/libc/include/machine/ieeefp.h
+++ b/newlib/libc/include/machine/ieeefp.h
@@ -249,6 +249,16 @@
 #define __IEEE_BIG_ENDIAN
 #endif
 
+// pre-defined compiler macro (from llc -march=cpu0${ENDIAN} or 
+// clang -target cpu0${ENDIAN}-unknown-linux-gnu 
+// http://beefchunk.com/documentation/lang/c/pre-defined-c/prearch.html 
+#ifdef __CPU0EL__
+#define __IEEE_LITTLE_ENDIAN
+#endif
+#ifdef __CPU0EB__
+#define __IEEE_BIG_ENDIAN
+#endif
+
 #ifdef __MMIX__
 #define __IEEE_BIG_ENDIAN
 #endif
@@ -507,4 +517,3 @@
 
 #endif /* not __IEEE_LITTLE_ENDIAN */
 #endif /* not __IEEE_BIG_ENDIAN */
-
diff --git a/newlib/libc/include/sys/unistd.h b/newlib/libc/include/sys/unistd.h
index 3cc313080..605929173 100644
--- a/newlib/libc/include/sys/unistd.h
+++ b/newlib/libc/include/sys/unistd.h
@@ -50,7 +50,7 @@ int     dup3 (int __fildes, int __fildes2, int flags);
 int	eaccess (const char *__path, int __mode);
 #endif
 #if __XSI_VISIBLE
-void	encrypt (char *__block, int __edflag);
+void	encrypt (char *__libc_block, int __edflag);
 #endif
 #if __BSD_VISIBLE || (__XSI_VISIBLE &amp;&amp; __XSI_VISIBLE &lt; 500)
 void	endusershell (void);
diff --git a/newlib/libc/machine/configure b/newlib/libc/machine/configure
index 62064cdfd..5ef5eec08 100755
--- a/newlib/libc/machine/configure
+++ b/newlib/libc/machine/configure
@@ -823,6 +823,7 @@ csky
 d10v
 d30v
 epiphany
+cpu0
 fr30
 frv
 ft32
@@ -12007,6 +12008,8 @@ subdirs=&quot;$subdirs a29k&quot;
 	d30v) subdirs=&quot;$subdirs d30v&quot;
  ;;
 	epiphany) subdirs=&quot;$subdirs epiphany&quot;
+ ;;
+	cpu0) subdirs=&quot;$subdirs cpu0&quot;
  ;;
 	fr30) subdirs=&quot;$subdirs fr30&quot;
  ;;
</pre></div>
</div>
<p class="rubric">lbt/exlbt/newlib-cygwin/newlib/libc/machine/cpu0/setjmp.S</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span># setjmp/longjmp for cpu0.  The jmpbuf looks like this:
#	
# Register	jmpbuf offset
# $9		0x00
# $10		0x04
# $11		0x08
# $12		0x0c
# $13		0x10
# $14		0x14
# $15		0x18
	
.macro save reg
	st	\reg,@r4
	add	#4,r4
.endm
	
.macro restore reg
	ld	@r4,\reg
	add	#4,r4
.endm


	.text
	.global	setjmp
setjmp:
	st $9,  0($a0)
	st $10, 4($a0)
	st $11, 8($a0)
	st $12, 12($a0)
	st $13, 16($a0)
	st $14, 20($a0)
	st $15, 24($a0)
# Return 0 to caller.
	addiu $lr, $zero, 0x0
	ret $lr

	.global	longjmp
longjmp:
	ld $9,  0($a0)
	ld $10, 4($a0)
	ld $11, 8($a0)
	ld $12, 12($a0)
	ld $13, 16($a0)
	ld $14, 20($a0)
	ld $15, 24($a0)

# If caller attempted to return 0, return 1 instead.
        cmp     $sw, $5,$0
        jne     $sw, $BB1
        addiu   $5,$0,1
$BB1:
        addu    $2,$0,$5
        ret	$lr
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">cschen@cschendeiMac exlbt % </span>bash newlib-cpu0.sh
</pre></div>
</div>
<p>The libm.a depends on variable errno of libc only defined in sys/errno.h.</p>
</section>
<section id="compiler-rt">
<h2><a class="toc-backref" href="#id17">Compiler-rt</a><a class="headerlink" href="#compiler-rt" title="Permalink to this headline">¶</a></h2>
<p>Compiler-rt is a project with runtime libraries implentation <a class="footnote-reference brackets" href="#id11" id="id3">3</a> .
Compiler-rt/lib/builtins provides functions for basic operations such as +, -,
*, /, … on type of float or double and for conversion between float and
integer, or on type of over 32-bit. The compiler-rt/lib/builtins/README.txt
<a class="footnote-reference brackets" href="#builtins-readme" id="id4">4</a> includes the dependent functions the whole builtins called.
The dependent functions is a small part of libm listed in
compier-rt/lib/builtins/int_math.h <a class="footnote-reference brackets" href="#builtins-int-math" id="id5">5</a> .</p>
<table class="docutils align-default" id="id15">
<caption><span class="caption-number">Table 4 </span><span class="caption-text">compiler-rt builtins dependences on newlib/libm (open source libc for bare metal)</span><a class="headerlink" href="#id15" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 29%" />
<col style="width: 71%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>library</p></th>
<th class="head"><p>functions</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>ported already</p></td>
<td><p>abort</p></td>
</tr>
<tr class="row-odd"><td><p>libm/common</p></td>
<td><p>finite, isinf, isnan</p></td>
</tr>
<tr class="row-even"><td><p>libm/complex</p></td>
<td><p>cabs</p></td>
</tr>
<tr class="row-odd"><td><p>libm/math</p></td>
<td><p>copysign, fcabs, fmax, log, scalbn</p></td>
</tr>
<tr class="row-even"><td><p>libm/mathfp</p></td>
<td><p>cabs</p></td>
</tr>
</tbody>
</table>
<ul class="simple">
<li><p>fabs (may includes fabsf, fabsl).</p></li>
<li><p>Only type of complex need above, others (float and double) depend on abort()
only which I ported in lbt/exlbt/compiler-rt/cpu0/abort.c.</p></li>
<li><p>All test cases in compiler-rt/test/builtins/Unit depend on
printf(%lld or %llX, …), I ported from
compiler-rt/lib/sanitizer_common/sanitizer_printf.cpp to
lbt/exlbt/input/sanitizer_printf.cpp.</p></li>
<li><p>These dependent functions from has bee ported from newlib/libm.</p></li>
<li><p>Except builtins, the other three, sanitizer runtimes, profile and BlocksRuntime,
are not needed for my embedded Cpu0.</p></li>
</ul>
<p>The libgcc’s Integer plus Soft float library  <a class="footnote-reference brackets" href="#lib-gcc" id="id6">6</a> <a class="footnote-reference brackets" href="#int-lib" id="id7">7</a>
<a class="footnote-reference brackets" href="#sw-float-lib" id="id8">8</a> are equal to functions of compiler-rt’s builtins.</p>
<p>Though the ‘rt’ means RunTime libaraies, in builtins library,
most of these functions
written in target-independent C form and can be compiled and static-linked
into target. When you compile the following c code, llc generates
<strong>jsub __addsf3</strong> to call compiler-rt float function since Cpu0 hasn’t hardware
float-instructions so Cpu0 backend doesn’t handle it, and llvm treats it
as a function call for float-add instruction.</p>
<p class="rubric">lbt/exlbt/input/ch_call_compilerrt_func.c</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">clang</span> <span class="o">-</span><span class="n">target</span> <span class="n">mips</span><span class="o">-</span><span class="n">unknown</span><span class="o">-</span><span class="n">linux</span><span class="o">-</span><span class="n">gnu</span> <span class="o">-</span><span class="n">S</span> <span class="n">ch_call_compilerrt_func</span><span class="o">.</span><span class="n">c</span> <span class="o">-</span><span class="n">emit</span><span class="o">-</span><span class="n">llvm</span> <span class="o">-</span><span class="n">o</span> <span class="n">ch_call_compilerrt_func</span><span class="o">.</span><span class="n">ll</span>
<span class="o">//</span> <span class="o">~/</span><span class="n">llvm</span><span class="o">/</span><span class="n">test</span><span class="o">/</span><span class="n">build</span><span class="o">/</span><span class="nb">bin</span><span class="o">/</span><span class="n">llc</span> <span class="o">-</span><span class="n">march</span><span class="o">=</span><span class="n">cpu0</span> <span class="o">-</span><span class="n">mcpu</span><span class="o">=</span><span class="n">cpu032II</span> <span class="o">-</span><span class="n">relocation</span><span class="o">-</span><span class="n">model</span><span class="o">=</span><span class="n">static</span> <span class="o">-</span><span class="n">filetype</span><span class="o">=</span><span class="n">asm</span> <span class="n">ch_call_compilerrt_func</span><span class="o">.</span><span class="n">ll</span> <span class="o">-</span><span class="n">o</span> <span class="o">-</span>

<span class="o">///</span> <span class="n">start</span>
<span class="nb">float</span> <span class="n">ch_call_compilerrt_func</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nb">float</span> <span class="n">a</span> <span class="o">=</span> <span class="mf">3.1</span><span class="p">;</span>
  <span class="nb">float</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">2.2</span><span class="p">;</span>
  <span class="nb">float</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>

</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">chungshu@ChungShudeMacBook-Air input % </span>clang -target mips-unknown-linux-gnu -S
<span class="go">ch_call_compilerrt_func.c -emit-llvm</span>
<span class="gp">chungshu@ChungShudeMacBook-Air input % </span>cat ch_call_compilerrt_func.ll
<span class="go">  ...</span>
<span class="gp">  %</span><span class="nv">4</span> <span class="o">=</span> load float, float* %1, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">5</span> <span class="o">=</span> load float, float* %2, align <span class="m">4</span>
<span class="gp">  %</span><span class="nv">6</span> <span class="o">=</span> fadd float %4, %5

<span class="gp">chungshu@ChungShudeMacBook-Air input % </span>~/llvm/test/build/bin/llc -march<span class="o">=</span>cpu0
<span class="go">-mcpu=cpu032II -relocation-model=static -filetype=asm ch_call_compilerrt_func.ll -o -</span>
<span class="go">      ...</span>
<span class="go">      ld      $4, 20($fp)</span>
<span class="go">      ld      $5, 16($fp)</span>
<span class="go">      jsub    __addsf3</span>
</pre></div>
</div>
<p>For some brar-metal or embedded application, the C code doesn’t need the
file and high-level IO in libc.
Libm provides a lots of functions to support software floating point beyond
basic operations <a class="footnote-reference brackets" href="#math" id="id9">9</a> .
Libc provides file, high-level IO functions and basic float functions <a class="footnote-reference brackets" href="#clib" id="id10">10</a> .</p>
<p>Cpu0 hires Compiler-rt/lib/builtins and
compiler-rt/lib/sanitizer_common/sanitizer_printf.cpp at this point.
The compiler-rt/lib/builtins is a
target-independent C form of software float library implementation. Cpu0
implements compiler-rt-12.x/cpu0/abort.c only at this point for supporting
this feature.</p>
</section>
<section id="software-float-point-support">
<h2><a class="toc-backref" href="#id18">Software Float Point Support</a><a class="headerlink" href="#software-float-point-support" title="Permalink to this headline">¶</a></h2>
<p>The following sanitizer_printf.cpp extended from compiler-rt can support
printf(“%lld”). It’s implementation calling some floating lib functions
in compiler-rt/lib/builtins.</p>
<p class="rubric">exlbt/include/math.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#ifndef _MATH_H_</span>
<span class="c1">#define	_MATH_H_</span>

<span class="o">//</span><span class="c1">#ifdef HAS_COMPLEX</span>
 <span class="c1">#ifndef HUGE_VALF</span>
  <span class="c1">#define HUGE_VALF (1.0e999999999F)</span>
 <span class="c1">#endif</span>

 <span class="c1">#if !defined(INFINITY)</span>
  <span class="c1">#define INFINITY (HUGE_VALF)</span>
 <span class="c1">#endif</span>

 <span class="c1">#if !defined(NAN)</span>
  <span class="c1">#define NAN (0.0F/0.0F)</span>
 <span class="c1">#endif</span>

 <span class="nb">float</span> <span class="n">cabsf</span><span class="p">(</span><span class="nb">float</span> <span class="nb">complex</span><span class="p">)</span> <span class="p">;</span>
<span class="o">//</span><span class="c1">#endif</span>
<span class="c1">#endif</span>
</pre></div>
</div>
<p class="rubric">exlbt/include/stdio.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#ifndef _STDIO_H_</span>
<span class="c1">#define	_STDIO_H_</span>

<span class="c1">#define stdin   0</span>
<span class="c1">#define stdout  1</span>
<span class="c1">#define stderr  2</span>

<span class="c1">#define size_t unsigned int</span>

<span class="c1">#endif</span>
</pre></div>
</div>
<p class="rubric">exlbt/include/stdlib.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#ifndef _STDLIB_H_</span>
<span class="c1">#define	_STDLIB_H_</span>

<span class="c1">#ifdef __cplusplus</span>
<span class="n">extern</span> <span class="s2">&quot;C&quot;</span> <span class="p">{</span>
<span class="c1">#endif</span>

<span class="n">void</span> <span class="n">abort</span><span class="p">();</span>

<span class="c1">#ifdef __cplusplus</span>
<span class="p">}</span>
<span class="c1">#endif</span>

<span class="c1">#endif</span>
</pre></div>
</div>
<p class="rubric">exlbt/include/string.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#ifndef _STRING_H_</span>
<span class="c1">#define	_STRING_H_</span>


<span class="c1">#endif</span>
</pre></div>
</div>
<p class="rubric">exlbt/compiler-rt/cpu0/abort.c</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">abort</span><span class="p">()</span> <span class="p">{</span>
  <span class="o">//</span> <span class="n">cpu0</span><span class="o">.</span><span class="n">v</span><span class="p">:</span> <span class="n">ABORT</span> <span class="n">at</span> <span class="n">mem</span> <span class="mh">0x04</span>
  <span class="n">asm</span><span class="p">(</span><span class="s2">&quot;addiu $lr, $ZERO, 4&quot;</span><span class="p">);</span>
  <span class="n">asm</span><span class="p">(</span><span class="s2">&quot;ret $lr&quot;</span><span class="p">);</span> 
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">exlbt/input/sanitizer_internal_defs.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//===--</span> <span class="n">sanitizer_internal_defs</span><span class="o">.</span><span class="n">h</span> <span class="o">-------------------------------*-</span> <span class="n">C</span><span class="o">++</span> <span class="o">-*-===//</span>
<span class="o">//</span>
<span class="o">//</span> <span class="n">Part</span> <span class="n">of</span> <span class="n">the</span> <span class="n">LLVM</span> <span class="n">Project</span><span class="p">,</span> <span class="n">under</span> <span class="n">the</span> <span class="n">Apache</span> <span class="n">License</span> <span class="n">v2</span><span class="mf">.0</span> <span class="k">with</span> <span class="n">LLVM</span> <span class="n">Exceptions</span><span class="o">.</span>
<span class="o">//</span> <span class="n">See</span> <span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">llvm</span><span class="o">.</span><span class="n">org</span><span class="o">/</span><span class="n">LICENSE</span><span class="o">.</span><span class="n">txt</span> <span class="k">for</span> <span class="n">license</span> <span class="n">information</span><span class="o">.</span>
<span class="o">//</span> <span class="n">SPDX</span><span class="o">-</span><span class="n">License</span><span class="o">-</span><span class="n">Identifier</span><span class="p">:</span> <span class="n">Apache</span><span class="o">-</span><span class="mf">2.0</span> <span class="n">WITH</span> <span class="n">LLVM</span><span class="o">-</span><span class="n">exception</span>
<span class="o">//</span>
<span class="o">//===----------------------------------------------------------------------===//</span>
<span class="o">//</span>
<span class="o">//</span> <span class="n">This</span> <span class="n">file</span> <span class="ow">is</span> <span class="n">shared</span> <span class="n">between</span> <span class="n">AddressSanitizer</span> <span class="ow">and</span> <span class="n">ThreadSanitizer</span><span class="o">.</span>
<span class="o">//</span> <span class="n">It</span> <span class="n">contains</span> <span class="n">macro</span> <span class="n">used</span> <span class="ow">in</span> <span class="n">run</span><span class="o">-</span><span class="n">time</span> <span class="n">libraries</span> <span class="n">code</span><span class="o">.</span>
<span class="o">//===----------------------------------------------------------------------===//</span>
<span class="c1">#ifndef SANITIZER_DEFS_H</span>
<span class="c1">#define SANITIZER_DEFS_H</span>

<span class="o">//</span> <span class="n">For</span> <span class="n">portability</span> <span class="n">reasons</span> <span class="n">we</span> <span class="n">do</span> <span class="ow">not</span> <span class="n">include</span> <span class="n">stddef</span><span class="o">.</span><span class="n">h</span><span class="p">,</span> <span class="n">stdint</span><span class="o">.</span><span class="n">h</span> <span class="ow">or</span> <span class="nb">any</span> <span class="n">other</span>
<span class="o">//</span> <span class="n">system</span> <span class="n">header</span><span class="p">,</span> <span class="n">but</span> <span class="n">we</span> <span class="n">do</span> <span class="n">need</span> <span class="n">some</span> <span class="n">basic</span> <span class="n">types</span> <span class="n">that</span> <span class="n">are</span> <span class="ow">not</span> <span class="n">defined</span>
<span class="o">//</span> <span class="ow">in</span> <span class="n">a</span> <span class="n">portable</span> <span class="n">way</span> <span class="n">by</span> <span class="n">the</span> <span class="n">language</span> <span class="n">itself</span><span class="o">.</span>
<span class="n">namespace</span> <span class="n">__sanitizer</span> <span class="p">{</span>

<span class="c1">#if defined(_WIN64)</span>
<span class="o">//</span> <span class="mi">64</span><span class="o">-</span><span class="n">bit</span> <span class="n">Windows</span> <span class="n">uses</span> <span class="n">LLP64</span> <span class="n">data</span> <span class="n">model</span><span class="o">.</span>
<span class="n">typedef</span> <span class="n">unsigned</span> <span class="n">long</span> <span class="n">long</span> <span class="n">uptr</span><span class="p">;</span>
<span class="n">typedef</span> <span class="n">signed</span> <span class="n">long</span> <span class="n">long</span> <span class="n">sptr</span><span class="p">;</span>
<span class="c1">#else</span>
<span class="n">typedef</span> <span class="n">unsigned</span> <span class="n">long</span> <span class="n">uptr</span><span class="p">;</span>
<span class="n">typedef</span> <span class="n">signed</span> <span class="n">long</span> <span class="n">sptr</span><span class="p">;</span>
<span class="c1">#endif  // defined(_WIN64)</span>
<span class="c1">#if defined(__x86_64__)</span>
<span class="o">//</span> <span class="n">Since</span> <span class="n">x32</span> <span class="n">uses</span> <span class="n">ILP32</span> <span class="n">data</span> <span class="n">model</span> <span class="ow">in</span> <span class="mi">64</span><span class="o">-</span><span class="n">bit</span> <span class="n">hardware</span> <span class="n">mode</span><span class="p">,</span> <span class="n">we</span> <span class="n">must</span> <span class="n">use</span>
<span class="o">//</span> <span class="mi">64</span><span class="o">-</span><span class="n">bit</span> <span class="n">pointer</span> <span class="n">to</span> <span class="n">unwind</span> <span class="n">stack</span> <span class="n">frame</span><span class="o">.</span>
<span class="n">typedef</span> <span class="n">unsigned</span> <span class="n">long</span> <span class="n">long</span> <span class="n">uhwptr</span><span class="p">;</span>
<span class="c1">#else</span>
<span class="n">typedef</span> <span class="n">uptr</span> <span class="n">uhwptr</span><span class="p">;</span>
<span class="c1">#endif</span>

<span class="n">typedef</span> <span class="n">unsigned</span> <span class="n">char</span> <span class="n">u8</span><span class="p">;</span>
<span class="n">typedef</span> <span class="n">unsigned</span> <span class="n">short</span> <span class="n">u16</span><span class="p">;</span>
<span class="n">typedef</span> <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">u32</span><span class="p">;</span>
<span class="n">typedef</span> <span class="n">unsigned</span> <span class="n">long</span> <span class="n">long</span> <span class="n">u64</span><span class="p">;</span>
<span class="n">typedef</span> <span class="n">signed</span> <span class="n">char</span> <span class="n">s8</span><span class="p">;</span>
<span class="n">typedef</span> <span class="n">signed</span> <span class="n">short</span> <span class="n">s16</span><span class="p">;</span>
<span class="n">typedef</span> <span class="n">signed</span> <span class="nb">int</span> <span class="n">s32</span><span class="p">;</span>
<span class="n">typedef</span> <span class="n">signed</span> <span class="n">long</span> <span class="n">long</span> <span class="n">s64</span><span class="p">;</span>

<span class="o">//</span> <span class="n">Check</span> <span class="n">macro</span>
<span class="c1">#define RAW_CHECK_MSG(expr, msg) </span>

<span class="c1">#define RAW_CHECK(expr) RAW_CHECK_MSG(expr, #expr)</span>

<span class="c1">#define CHECK_IMPL(c1, op, c2)</span>

<span class="c1">#define CHECK(a)       CHECK_IMPL((a), !=, 0)</span>
<span class="c1">#define CHECK_EQ(a, b) CHECK_IMPL((a), ==, (b))</span>
<span class="c1">#define CHECK_NE(a, b) CHECK_IMPL((a), !=, (b))</span>
<span class="c1">#define CHECK_LT(a, b) CHECK_IMPL((a), &lt;,  (b))</span>
<span class="c1">#define CHECK_LE(a, b) CHECK_IMPL((a), &lt;=, (b))</span>
<span class="c1">#define CHECK_GT(a, b) CHECK_IMPL((a), &gt;,  (b))</span>
<span class="c1">#define CHECK_GE(a, b) CHECK_IMPL((a), &gt;=, (b))</span>

<span class="p">}</span>  <span class="o">//</span> <span class="n">namespace</span> <span class="n">__sanitizer</span>

<span class="c1">#endif</span>
</pre></div>
</div>
<p class="rubric">exlbt/input/sanitizer_printf.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>//===-- sanitizer_printf.cpp ----------------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This file is shared between AddressSanitizer and ThreadSanitizer.
//
// Internal printf function, used inside run-time libraries.
// We can&#39;t use libc printf because we intercept some of the functions used
// inside it.
//===----------------------------------------------------------------------===//

#include &quot;sanitizer_internal_defs.h&quot;

#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;

#include &quot;debug.h&quot;

extern &quot;C&quot; int putchar(int c);

extern void* internal_memset(void* b, int c, size_t len);

#if SANITIZER_WINDOWS &amp;&amp; defined(_MSC_VER) &amp;&amp; _MSC_VER &lt; 1800 &amp;&amp;               \
      !defined(va_copy)
# define va_copy(dst, src) ((dst) = (src))
#endif

namespace __sanitizer {

static int strlen(const char* s) {
  int len = 0;
  for (const char* p = s; *p != &#39;\0&#39;; p++) {
    len++;
  }
  return len;
}

static int AppendChar(char **buff, const char *buff_end, char c) {
  if (*buff &lt; buff_end) {
    **buff = c;
    (*buff)++;
  }
  return 1;
}

// Appends number in a given base to buffer. If its length is less than
// |minimal_num_length|, it is padded with leading zeroes or spaces, depending
// on the value of |pad_with_zero|.
static int AppendNumber(char **buff, const char *buff_end, u64 absolute_value,
                        u8 base, u8 minimal_num_length, bool pad_with_zero,
                        bool negative, bool uppercase, bool left_justified) {
  uptr const kMaxLen = 30;
  RAW_CHECK(base == 10 || base == 16);
  RAW_CHECK(base == 10 || !negative);
  RAW_CHECK(absolute_value || !negative);
  RAW_CHECK(minimal_num_length &lt; kMaxLen);
  int result = 0;
  if (negative &amp;&amp; minimal_num_length)
    --minimal_num_length;
  if (negative &amp;&amp; pad_with_zero)
    result += AppendChar(buff, buff_end, &#39;-&#39;);
  uptr num_buffer[kMaxLen];
  int num_pads = 0;
  int pos = 0;
  do {
    RAW_CHECK_MSG((uptr)pos &lt; kMaxLen, &quot;AppendNumber buffer overflow&quot;);
    num_buffer[pos++] = absolute_value % base;
    absolute_value /= base;
  } while (absolute_value &gt; 0);
  if (pos &lt; minimal_num_length) {
    // Make sure compiler doesn&#39;t insert call to memset here.
    internal_memset(&amp;num_buffer[pos], 0,
                    sizeof(num_buffer[0]) * (minimal_num_length - pos));
    num_pads = minimal_num_length - pos;
    pos = minimal_num_length;
  }
  RAW_CHECK(pos &gt; 0);
  pos--;
  for (; pos &gt;= 0 &amp;&amp; num_buffer[pos] == 0; pos--) {
    char c = (pad_with_zero || pos == 0) ? &#39;0&#39; : &#39; &#39;;
    if (!left_justified)
      result += AppendChar(buff, buff_end, c);
  }
  if (negative &amp;&amp; !pad_with_zero) result += AppendChar(buff, buff_end, &#39;-&#39;);
  for (; pos &gt;= 0; pos--) {
    char digit = static_cast&lt;char&gt;(num_buffer[pos]);
    digit = (digit &lt; 10) ? &#39;0&#39; + digit : (uppercase ? &#39;A&#39; : &#39;a&#39;) + digit - 10;
    result += AppendChar(buff, buff_end, digit);
  }
  if (left_justified) {
    for (int i = 0; i &lt; num_pads; i++)
      result += AppendChar(buff, buff_end, &#39; &#39;);
  }
  return result;
}

static int AppendUnsigned(char **buff, const char *buff_end, u64 num, u8 base,
                          u8 minimal_num_length, bool pad_with_zero,
                          bool uppercase, bool left_justified) {
  return AppendNumber(buff, buff_end, num, base, minimal_num_length,
                      pad_with_zero, false /* negative */, uppercase, 
                      left_justified);
}

static int AppendSignedDecimal(char **buff, const char *buff_end, s64 num,
                               u8 minimal_num_length, bool pad_with_zero,
                               bool left_justified) {
  bool negative = (num &lt; 0);
  return AppendNumber(buff, buff_end, (u64)(negative ? -num : num), 10,
                      minimal_num_length, pad_with_zero, negative,
                      false /* uppercase */, left_justified);
}


// Use the fact that explicitly requesting 0 width (%0s) results in UB and
// interpret width == 0 as &quot;no width requested&quot;:
// width == 0 - no width requested
// width  &lt; 0 - left-justify s within and pad it to -width chars, if necessary
// width  &gt; 0 - right-justify s, implement for cpu0
static int AppendString(char **buff, const char *buff_end, int width,
                        int max_chars, const char *s, bool left_justified) {
  if (!s)
    s = &quot;&lt;null&gt;&quot;;
  int result = 0;
  if (!left_justified) {
    int s_len = strlen(s);
    while (result &lt; width - s_len)
      result += AppendChar(buff, buff_end, &#39; &#39;);
  }
  for (; *s; s++) {
    if (max_chars &gt;= 0 &amp;&amp; result &gt;= max_chars)
      break;
    result += AppendChar(buff, buff_end, *s);
  }
  if (left_justified) {
    while (width &lt; -result)
      result += AppendChar(buff, buff_end, &#39; &#39;);
  }
  return result;
}

static int AppendPointer(char **buff, const char *buff_end, u64 ptr_value,
                         bool left_justified) {
  int result = 0;
  result += AppendString(buff, buff_end, 0, -1, &quot;0x&quot;, left_justified);
  result += AppendUnsigned(buff, buff_end, ptr_value, 16,
// By running clang -E, can get the macro value for SANITIZER_POINTER_FORMAT_LENGTH is (12)
//                           SANITIZER_POINTER_FORMAT_LENGTH,
                           (12),
                           true /* pad_with_zero */, false /* uppercase */,
                           left_justified);
  return result;
}

int VSNPrintf(char *buff, int buff_length,
              const char *format, va_list args) {
  static const char *kPrintfFormatsHelp =
      &quot;Supported Printf formats: %([0-9]*)?(z|ll)?{d,u,x,X}; %p; &quot;
      &quot;%[-]([0-9]*)?(\\.\\*)?s; %c\n&quot;;
  RAW_CHECK(format);
  RAW_CHECK(buff_length &gt; 0);
  const char *buff_end = &amp;buff[buff_length - 1];
  const char *cur = format;
  int result = 0;
  for (; *cur; cur++) {
    if (*cur != &#39;%&#39;) {
      result += AppendChar(&amp;buff, buff_end, *cur);
      continue;
    }
    cur++;
    bool left_justified = *cur == &#39;-&#39;;
    if (left_justified)
      cur++;
    bool have_width = (*cur &gt;= &#39;0&#39; &amp;&amp; *cur &lt;= &#39;9&#39;);
    bool pad_with_zero = (*cur == &#39;0&#39;);
    int width = 0;
    if (have_width) {
      while (*cur &gt;= &#39;0&#39; &amp;&amp; *cur &lt;= &#39;9&#39;) {
        width = width * 10 + *cur++ - &#39;0&#39;;
      }
    }
    bool have_precision = (cur[0] == &#39;.&#39; &amp;&amp; cur[1] == &#39;*&#39;);
    int precision = -1;
    if (have_precision) {
      cur += 2;
      precision = va_arg(args, int);
    }
    bool have_z = (*cur == &#39;z&#39;);
    cur += have_z;
    bool have_ll = !have_z &amp;&amp; (cur[0] == &#39;l&#39; &amp;&amp; cur[1] == &#39;l&#39;);
    cur += have_ll * 2;
    s64 dval;
    u64 uval;
    const bool have_length = have_z || have_ll;
    const bool have_flags = have_width || have_length;
    // At the moment only %s supports precision and left-justification.
    CHECK(!((precision &gt;= 0 || left_justified) &amp;&amp; *cur != &#39;s&#39;));
    switch (*cur) {
      case &#39;d&#39;: {
        dval = have_ll ? va_arg(args, s64)
             : have_z ? va_arg(args, sptr)
             : va_arg(args, int);
        result += AppendSignedDecimal(&amp;buff, buff_end, dval, width,
                                      pad_with_zero, left_justified);
        break;
      }
      case &#39;u&#39;:
      case &#39;x&#39;:
      case &#39;X&#39;: {
        uval = have_ll ? va_arg(args, u64)
             : have_z ? va_arg(args, uptr)
             : va_arg(args, unsigned);
        bool uppercase = (*cur == &#39;X&#39;);
        result += AppendUnsigned(&amp;buff, buff_end, uval, (*cur == &#39;u&#39;) ? 10 : 16,
                                 width, pad_with_zero, uppercase, left_justified);
        break;
      }
      case &#39;p&#39;: {
        RAW_CHECK_MSG(!have_flags, kPrintfFormatsHelp);
        result += AppendPointer(&amp;buff, buff_end, va_arg(args, uptr),
                                left_justified);
        break;
      }
      case &#39;s&#39;: {
        RAW_CHECK_MSG(!have_length, kPrintfFormatsHelp);
        CHECK(!have_width || left_justified);
        result += AppendString(&amp;buff, buff_end, left_justified ? -width : width,
                               precision, va_arg(args, char*), left_justified);
        break;
      }
      case &#39;c&#39;: {
        RAW_CHECK_MSG(!have_flags, kPrintfFormatsHelp);
        result += AppendChar(&amp;buff, buff_end, va_arg(args, int));
        break;
      }
      case &#39;%&#39; : {
        RAW_CHECK_MSG(!have_flags, kPrintfFormatsHelp);
        result += AppendChar(&amp;buff, buff_end, &#39;%&#39;);
        break;
      }
      default: {
        RAW_CHECK_MSG(false, kPrintfFormatsHelp);
      }
    }
  }
  RAW_CHECK(buff &lt;= buff_end);
  AppendChar(&amp;buff, buff_end + 1, &#39;\0&#39;);
  return result;
}

} // namespace __sanitizer

int prints(const char *string)
{
  int pc = 0, padchar = &#39; &#39;;

  for ( ; *string ; ++string) {
    putchar (*string);
    ++pc;
  }

  return pc;
}

extern &quot;C&quot; int sprintf(char *buffer, const char *format, ...) {
  int length = 1000;
  va_list args;
  va_start(args, format);
  int needed_length = __sanitizer::VSNPrintf(buffer, length, format, args);
  va_end(args);
  return 0;
}

extern &quot;C&quot; int printf(const char *format, ...) {
  int length = 1000;
  char buffer[1000];
  va_list args;
  va_start(args, format);
  int needed_length = __sanitizer::VSNPrintf(buffer, length, format, args);
  va_end(args);
  prints(buffer);
  return 0;
}

extern &quot;C&quot; int san_printf(const char *format, ...) {
  int length = 1000;
  char buffer[1000];
  va_list args;
  va_start(args, format);
  int needed_length = __sanitizer::VSNPrintf(buffer, length, format, args);
  va_end(args);
  prints(buffer);
  return 0;
}
</pre></div>
</div>
<p>Above two sanitizer_*.* files are ported from compiler-rt and I add code to
support left-justify for number-printf and right-justify for string-printf.
The following ch_float.cpp test the float lib.</p>
<p class="rubric">lbt/exlbt/compiler-rt-12.x/builtins/Makefile</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span># Thanks .c .cb Vranish (https://spin.a.cmi.cbject..cm/2016/08/26/makefile-c-p.cjects/)

# CPU and endian passed from command line, such as &quot;make CPU=cpu032II ENDIAN=el&quot;

TARGET_LIB := libbuiltins.a
BUILD_DIR := ./build-$(CPU)-$(ENDIAN)
TARGET := $(BUILD_DIR)/$(TARGET_LIB)

SRC_DIR := $(HOME)/llvm/llvm-project/compiler-rt/lib/builtins

PWD := $(shell pwd)

TOOLDIR := ~/llvm/test/build/bin
CC := $(TOOLDIR)/clang
AR := $(TOOLDIR)/llvm-ar

# copy GENERIC_SOURCES from compiler-rt/lib/builtin/CMakeLists.txt
GENERIC_SOURCES := \
  absvdi2.c \
  absvsi2.c \
  absvti2.c \
  adddf3.c \
  addsf3.c \
  addvdi3.c \
  addvsi3.c \
  addvti3.c \
  apple_versioning.c \
  ashldi3.c \
  ashlti3.c \
  ashrdi3.c \
  ashrti3.c \
  bswapdi2.c \
  bswapsi2.c \
  clzdi2.c \
  clzsi2.c \
  clzti2.c \
  cmpdi2.c \
  cmpti2.c \
  comparedf2.c \
  comparesf2.c \
  ctzdi2.c \
  ctzsi2.c \
  ctzti2.c \
  divdc3.c \
  divdf3.c \
  divdi3.c \
  divsc3.c \
  divtc3.c \
  divmoddi4.c \
  divmodsi4.c \
  divmodti4.c \
  divsc3.c \
  divsf3.c \
  divsi3.c \
  divti3.c \
  divxc3.c \
  extendsfdf2.c \
  extendhfsf2.c \
  ffsdi2.c \
  ffssi2.c \
  ffsti2.c \
  fixdfdi.c \
  fixdfsi.c \
  fixdfti.c \
  fixsfdi.c \
  fixsfsi.c \
  fixsfti.c \
  fixunsdfdi.c \
  fixunsdfsi.c \
  fixunsdfti.c \
  fixunssfdi.c \
  fixunssfsi.c \
  fixunssfti.c \
  floatdidf.c \
  floatdisf.c \
  floatsidf.c \
  floatsisf.c \
  floattidf.c \
  floattisf.c \
  floatundidf.c \
  floatundisf.c \
  floatunsidf.c \
  floatunsisf.c \
  floatuntidf.c \
  floatuntisf.c \
  fp_mode.c \
  int_util.c \
  lshrdi3.c \
  lshrti3.c \
  moddi3.c \
  modsi3.c \
  modti3.c \
  muldc3.c \
  muldf3.c \
  muldi3.c \
  mulodi4.c \
  mulosi4.c \
  muloti4.c \
  mulsc3.c \
  mulsf3.c \
  multi3.c \
  mulvdi3.c \
  mulvsi3.c \
  mulvti3.c \
  mulxc3.c \
  negdf2.c \
  negdi2.c \
  negsf2.c \
  negti2.c \
  negvdi2.c \
  negvsi2.c \
  negvti2.c \
  os_version_check.c \
  paritydi2.c \
  paritysi2.c \
  parityti2.c \
  popcountdi2.c \
  popcountsi2.c \
  popcountti2.c \
  powidf2.c \
  powisf2.c \
  subdf3.c \
  subsf3.c \
  subvdi3.c \
  subvsi3.c \
  subvti3.c \
  trampoline_setup.c \
  truncdfhf2.c \
  truncdfsf2.c \
  truncsfhf2.c \
  ucmpdi2.c \
  ucmpti2.c \
  udivdi3.c \
  udivmoddi4.c \
  udivmodsi4.c \
  udivmodti4.c \
  udivsi3.c \
  udivti3.c \
  umoddi3.c \
  umodsi3.c \
  umodti3.c

SRCS := $(GENERIC_SOURCES)

# String substitution for every C file.
# As an example, absvdi2.c turns into ./builtins/absvdi2.c
SRCS := $(SRCS:%=$(SRC_DIR)/%) $(PWD)/../cpu0/abort.c

# String substitution for every C/C++ file.
# As an example, absvdi2.c turns into ./build-$(CPU)-$(ENDIAN)/absvdi2.c.o
OBJS := $(SRCS:%=$(BUILD_DIR)/%.o)

# String substitution (suffix version without %).
# As an example, ./build/absvdi2.c.o turns into ./build-$(CPU)-$(ENDIAN)/absvdi2.c.d
DEPS := $(OBJS:.o=.d)

# Every folder in ./src will need to be passed to GCC so that it can find header files
# stdlib.h, ..., etc existed in ../../include
INC_DIRS := $(shell find $(SRC_DIR) -type d)  ../../include
# Add a prefix to INC_DIRS. So moduleA would become -ImoduleA. GCC understands this -I flag
INC_FLAGS := $(addprefix -I,$(INC_DIRS))

# The -MMD and -MP flags together generate Makefiles for us!
# These files will have .d instead of .o as the output.
CPPFLAGS := -MMD -MP -target cpu0$(ENDIAN)-unknown-linux-gnu -static \
  -fintegrated-as $(INC_FLAGS) -mcpu=$(CPU) -mllvm -has-lld=true

# The final build step.
$(TARGET): $(OBJS)
	$(AR) -rcs $@ $(OBJS)

# Build step for C source
$(BUILD_DIR)/%.c.o: %.c
	mkdir -p $(dir $@)
	$(CC) $(CPPFLAGS) $(CFLAGS) -c $&lt; -o $@


.PHONY: clean
clean:
	rm -rf $(BUILD_DIR)

# Include the .d makefiles. The - at the f.cnt suppresses the er.crs.cf missing
# Makefiles. Initially, all the .d files will be missing, and we .cn&#39;t want t.cse
# er.crs .c s.cw up.
-include $(DEPS)
</pre></div>
</div>
<p class="rubric">exlbt/input/ch_float.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>//#include &quot;debug.h&quot;

extern &quot;C&quot; int printf(const char *format, ...);
extern &quot;C&quot; int sprintf(char *out, const char *format, ...);

#include &quot;ch9_3_longlongshift.cpp&quot;

void test_printf()
{
  char buf[80];
  long long a = 0x100000007fffffff;
  printf(&quot;a: %llX, %llx, %lld\n&quot;, a, a, a);
  int b = 0x10000000;
  printf(&quot;b: %x, %d\n&quot;, b, b);
  sprintf(buf, &quot;b: %x, %d\n&quot;, b, b); printf(&quot;%s&quot;, buf);

  // sanitizer_printf.cpp support right-justify for num only and left-justify
  // for string only. However, I change and support right-justify for cpu0.
  char ptr[] = &quot;Hello world!&quot;;
  char *np = 0;
  int i = 5;
  unsigned int bs = sizeof(int)*8;
  int mi;

  mi = (1 &lt;&lt; (bs-1)) + 1;
  printf(&quot;%s\n&quot;, ptr);
  printf(&quot;printf test\n&quot;);
  printf(&quot;%s is null pointer\n&quot;, np);
  printf(&quot;%d = 5\n&quot;, i);
  printf(&quot;%d = - max int\n&quot;, mi);
  printf(&quot;char %c = &#39;a&#39;\n&quot;, &#39;a&#39;);
  printf(&quot;hex %x = ff\n&quot;, 0xff);
  printf(&quot;hex %02x = 00\n&quot;, 0);
  printf(&quot;signed %d = unsigned %u = hex %x\n&quot;, -3, -3, -3);
  printf(&quot;%d %s(s)&quot;, 0, &quot;message&quot;);
  printf(&quot;\n&quot;);
  printf(&quot;%d %s(s) with %%\n&quot;, 0, &quot;message&quot;);
  sprintf(buf, &quot;justif: \&quot;%-10s\&quot;\n&quot;, &quot;left&quot;); printf(&quot;%s&quot;, buf);
  sprintf(buf, &quot;justif: \&quot;%10s\&quot;\n&quot;, &quot;right&quot;); printf(&quot;%s&quot;, buf);
  sprintf(buf, &quot; 3: %04d zero padded\n&quot;, 3); printf(&quot;%s&quot;, buf);
  sprintf(buf, &quot; 3: %-4d left justif.\n&quot;, 3); printf(&quot;%s&quot;, buf);
  sprintf(buf, &quot; 3: %4d right justif.\n&quot;, 3); printf(&quot;%s&quot;, buf);
  sprintf(buf, &quot;-3: %04d zero padded\n&quot;, -3); printf(&quot;%s&quot;, buf);
  sprintf(buf, &quot;-3: %-4d left justif.\n&quot;, -3); printf(&quot;%s&quot;, buf);
  sprintf(buf, &quot;-3: %4d right justif.\n&quot;, -3); printf(&quot;%s&quot;, buf);
}

template &lt;class T&gt;
T test_shift_left(T a, T b) {
  return (a &lt;&lt; b);
}

template &lt;class T&gt;
T test_shift_right(T a, T b) {
  return (a &gt;&gt; b);
}

template &lt;class T1, class T2, class T3&gt;
T1 test_add(T2 a, T3 b) {
  T1 c = a + b;
  return c;
}

template &lt;class T1, class T2, class T3&gt;
T1 test_mul(T2 a, T3 b) {
  T1 c = a * b;
  return c;
}

template &lt;class T1, class T2, class T3&gt;
T1 test_div(T2 a, T3 b) {
  T1 c = a / b;
  return c;
}

bool check_result(const char* fn, long long res, long long expected) {
  printf(&quot;%s = %lld\n&quot;, fn, res);
  if (res != expected) {
    printf(&quot;\terror: result %lld, expected %lld\n&quot;, res, expected);
  }
  return (res == expected);
}

bool check_result(const char* fn, unsigned long long res, unsigned long long expected) {
  printf(&quot;%s = %llu\n&quot;, fn, res);
  if (res != expected) {
    printf(&quot;\terror: result %llu, expected %llu\n&quot;, res, expected);
  }
  return (res == expected);
}

bool check_result(const char* fn, int res, int expected) {
  printf(&quot;%s = %d\n&quot;, fn, res);
  if (res != expected) {
    printf(&quot;\terror: result %d, expected %d\n&quot;, res, expected);
  }
  return (res == expected);
}

int main() {
  long long a;
  unsigned long long b;
  int c;

  test_printf();

  a = test_longlong_shift1();
  check_result(&quot;test_longlong_shift1()&quot;, a, 289LL);

  a = test_longlong_shift2();
  check_result(&quot;test_longlong_shift2()&quot;, a, 22LL);

// call __ashldi3
  a = test_shift_left&lt;long long&gt;(0x12LL, 4LL); // 0x120 = 288
  check_result(&quot;test_shift_left&lt;long long&gt;(0x12LL, 4LL)&quot;, a, 288LL);
  
// call __ashrdi3
  a = test_shift_right&lt;long long&gt;(0x001666660000000a, 48LL); // 0x16 = 22
  check_result(&quot;test_shift_right&lt;long long&gt;(0x001666660000000a, 48LL)&quot;, a, 22LL);
  
// call __lshrdi3
  b = test_shift_right&lt;unsigned long long&gt;(0x001666660000000a, 48LLu); // 0x16 = 22
  check_result(&quot;test_shift_right&lt;unsigned long long&gt;(0x001666660000000a, 48LLu)&quot;, b, 22LLu);
  
// call __addsf3, __fixsfsi
  c = (int)test_add&lt;float, float, float&gt;(-2.2, 3.3); // (int)1.1 = 1
  check_result(&quot;(int)test_add&lt;float, float, float&gt;(-2.2, 3.3)&quot;, c, 1);
  
// call __mulsf3, __fixsfsi
  c = (int)test_mul&lt;float, float, float&gt;(-2.2, 3.3); // (int)-7.26 = -7
  check_result(&quot;(int)test_mul&lt;float, float, float&gt;(-2.2, 3.3)&quot;, c, -7);
  
// call __divsf3, __fixsfsi
  c = (int)test_div&lt;float, float, float&gt;(-1.8, 0.5); // (int)-3.6 = -3
  check_result(&quot;(int)test_div&lt;float, float, float&gt;(-1.8, 0.5)&quot;, c, -3);
  
// call __extendsfdf2, __adddf3, __fixdfsi
  c = (int)test_add&lt;double, double, float&gt;(-2.2, 3.3); // (int)1.1 = 1
  check_result(&quot;(int)test_add&lt;double, double, float&gt;(-2.2, 3.3)&quot;, c, 1);
  
// call __extendsfdf2, __adddf3, __fixdfsi
  c = (int)test_add&lt;double, float, double&gt;(-2.2, 3.3); // (int)1.1 = 1
  check_result(&quot;(int)test_add&lt;double, float, double&gt;(-2.2, 3.3)&quot;, c, 1);
  
// call __extendsfdf2, __adddf3, __fixdfsi
  c = (int)test_add&lt;float, float, double&gt;(-2.2, 3.3); // (int)1.1 = 1
  check_result(&quot;(int)test_add&lt;float, float, double&gt;(-2.2, 3.3)&quot;, c, 1);
  
// call __extendsfdf2, __muldf3, __fixdfsi
  c = (int)test_mul&lt;double, float, double&gt;(-2.2, 3.3); // (int)-7.26 = -7
  check_result(&quot;(int)test_mul&lt;double, float, double&gt;(-2.2, 3.3)&quot;, c, -7);
  
// call __extendsfdf2, __muldf3, __truncdfsf2, __fixdfsi
// ! __truncdfsf2 in truncdfsf2.c is not work for Cpu0
  c = (int)test_mul&lt;float, float, double&gt;(-2.2, 3.3); // (int)-7.26 = -7
  check_result(&quot;(int)test_mul&lt;float, float, double&gt;(-2.2, 3.3)&quot;, c, -7);
  
// call __divdf3, __fixdfsi
  c = (int)test_div&lt;double, double, double&gt;(-1.8, 0.5); // (int)-3.6 = -3
  check_result(&quot;(int)test_div&lt;double, double, double&gt;(-1.8, 0.5)&quot;, c, -3);

#if 0 // these three do call builtins  
  c = (int)test_mul&lt;int, int, int&gt;(-2, 3); // -6
  check_result(&quot;(int)test_mul&lt;int, int, int&gt;(-2, 3)&quot;, c, -6);
  
  c = (int)test_div&lt;int, int, int&gt;(-10, 4); // -2 &lt;- -2*4+2, quotient:-2, remainder:2 (remainder &lt; 4:divident)
  check_result(&quot;(int)test_div&lt;int, int, int&gt;(-10, 4)&quot;, c, -3);
  
  a = test_mul&lt;long long, long long, long long&gt;(-2LL, 3LL); // -6LL
  check_result(&quot;test_mul&lt;long long, long long, long long&gt;(-2LL, 3LL)&quot;, a, -6LL);
#endif

// call __divdi3,
  a = test_div&lt;long long, long long, long long&gt;(-10LL, 4LL); // -3
  check_result(&quot;test_div&lt;long long, long long, long long&gt;(-10LL, 4LL)&quot;, a, -2LL);
  
  return 0;
}

</pre></div>
</div>
<p class="rubric">exlbt/input/Makefile.float</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
SRCS := start.cpp debug.cpp sanitizer_printf.cpp printf-stdarg-def.c \
        cpu0-builtins.cpp ch_float.cpp lib_cpu0.c
LIBBUILTINS_DIR := ../compiler-rt/builtins
INC_DIRS := ../ $(NEWLIB_DIR)/newlib/libc/include $(LBDEX_DIR)/input
LIBS := $(LIBBUILTINS_DIR)/build-$(CPU)-$(ENDIAN)/libbuiltins.a

include Common.mk
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">chungshu@ChungShudeMacBook-Air input % </span>bash make.sh cpu032II eb Makefile.float
<span class="go">...</span>
<span class="go">endian =  BigEndian</span>
<span class="go">ISR address:00020614</span>
<span class="go">0   /* 0: big endian, 1: little endian */</span>

<span class="gp">chungshu@ChungShudeMacBook-Air verilog % </span>iverilog -o cpu0IIs cpu0IIs.v
<span class="gp">chungshu@ChungShudeMacBook-Air verilog % </span>./cpu0IIs
<span class="go">...</span>

<span class="go">a: 100000007FFFFFFF, 100000007fffffff, 1152921506754330623</span>
<span class="go">b: 10000000, 268435456</span>
<span class="go">b: 10000000, 268435456</span>
<span class="go">Hello world!</span>
<span class="go">printf test</span>
<span class="go">&lt;null&gt; is null pointer</span>
<span class="go">5 = 5</span>
<span class="go">-2147483647 = - max int</span>
<span class="go">char a = &#39;a&#39;</span>
<span class="go">hex ff = ff</span>
<span class="go">hex 00 = 00</span>
<span class="go">signed -3 = unsigned 4294967293 = hex fffffffd</span>
<span class="go">0 message(s)</span>
<span class="go">0 message(s) with %</span>
<span class="go">justif: &quot;left      &quot;</span>
<span class="go">justif: &quot;     right&quot;</span>
<span class="go"> 3: 0003 zero padded</span>
<span class="go"> 3: 3    left justif.</span>
<span class="go"> 3:    3 right justif.</span>
<span class="go">-3: -003 zero padded</span>
<span class="go">-3: -3   left justif.</span>
<span class="go">-3:   -3 right justif.</span>
<span class="go">test_longlong_shift1() = 289</span>
<span class="go">test_longlong_shift2() = 22</span>
<span class="go">test_shift_left&lt;long long&gt;(0x12, 4LL) = 288</span>
<span class="go">test_shift_right&lt;long long&gt;(0x001666660000000a, 48LL) = 22</span>
<span class="go">test_shift_right&lt;unsigned long long&gt;(0x001666660000000a, 48LLu) = 22</span>
<span class="gp gp-VirtualEnv">(int)</span><span class="go">test_add&lt;float, float, float&gt;(-2.2, 3.3) = 1</span>
<span class="gp gp-VirtualEnv">(int)</span><span class="go">test_mul&lt;float, float, float&gt;(-2.2, 3.3) = -7</span>
<span class="gp gp-VirtualEnv">(int)</span><span class="go">test_div&lt;float, float, float&gt;(-1.8, 0.5) = -3</span>
<span class="gp gp-VirtualEnv">(int)</span><span class="go">test_add&lt;double, double, float&gt;(-2.2, 3.3) = 1</span>
<span class="gp gp-VirtualEnv">(int)</span><span class="go">test_add&lt;double, float, double&gt;(-2.2, 3.3) = 1</span>
<span class="gp gp-VirtualEnv">(int)</span><span class="go">test_add&lt;float, float, double&gt;(-2.2, 3.3) = 1</span>
<span class="gp gp-VirtualEnv">(int)</span><span class="go">test_mul&lt;double, float, double&gt;(-2.2, 3.3) = -7</span>
<span class="gp gp-VirtualEnv">(int)</span><span class="go">test_mul&lt;float, float, double&gt;(-2.2, 3.3) = -7</span>
<span class="gp gp-VirtualEnv">(int)</span><span class="go">test_div&lt;double, double, double&gt;(-1.8, 0.5) = -3</span>
<span class="go">test_div&lt;long long, long long, long long&gt;(-10LL, 4LL) = -2</span>
<span class="go">...</span>
<span class="go">RET to PC &lt; 0, finished!</span>
</pre></div>
</div>
<p>The exlbt/input/compiler-rt-test/builtins/Unit copied from
compiler-rt/test/builtins/Unit as follows,</p>
<p class="rubric">exlbt/input/ch_builtins.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>#include &quot;debug.h&quot;
#include &lt;stdlib.h&gt;

extern &quot;C&quot; int printf(const char *format, ...);
extern &quot;C&quot; int sprintf(char *out, const char *format, ...);

extern &quot;C&quot; int absvdi2_test();
extern &quot;C&quot; int absvsi2_test();
extern &quot;C&quot; int absvti2_test();
extern &quot;C&quot; int adddf3vfp_test();
extern &quot;C&quot; int addsf3vfp_test();
extern &quot;C&quot; int addvdi3_test();
extern &quot;C&quot; int addvsi3_test();
extern &quot;C&quot; int addvti3_test();
extern &quot;C&quot; int ashldi3_test();
extern &quot;C&quot; int ashlti3_test();
extern &quot;C&quot; int ashrdi3_test();
extern &quot;C&quot; int ashrti3_test();

// atomic.c need memcmp(...)
//extern &quot;C&quot; int atomic_test();
extern &quot;C&quot; int bswapdi2_test();
extern &quot;C&quot; int bswapsi2_test();

extern &quot;C&quot; int clzdi2_test();
extern &quot;C&quot; int clzsi2_test();
extern &quot;C&quot; int clzti2_test();
extern &quot;C&quot; int cmpdi2_test();
extern &quot;C&quot; int cmpti2_test();
extern &quot;C&quot; int comparedf2_test();
extern &quot;C&quot; int comparesf2_test();

// Needless to compare compiler_rt_logb() with logb() of libm
//extern &quot;C&quot; int compiler_rt_logb_test();
//extern &quot;C&quot; int compiler_rt_logbf_test();
//extern &quot;C&quot; int compiler_rt_logbl_test();

extern &quot;C&quot; int cpu_model_test();
extern &quot;C&quot; int ctzdi2_test();
extern &quot;C&quot; int ctzsi2_test();
extern &quot;C&quot; int ctzti2_test();

// div for complex type need libm: fabs, isinf, ..., skip it at this point
#ifdef HAS_COMPLEX
extern &quot;C&quot; int divdc3_test();
#endif
extern &quot;C&quot; int divdf3_test();
extern &quot;C&quot; int divdf3vfp_test();
extern &quot;C&quot; int divdi3_test();
extern &quot;C&quot; int divmodsi4_test();
extern &quot;C&quot; int divmodti4_test();
#ifdef HAS_COMPLEX
extern &quot;C&quot; int divsc3_test();
#endif
extern &quot;C&quot; int divsf3_test();
extern &quot;C&quot; int divsf3vfp_test();
extern &quot;C&quot; int divsi3_test();
#ifdef HAS_COMPLEX
extern &quot;C&quot; int divtc3_test();
#endif
extern &quot;C&quot; int divtf3_test();
extern &quot;C&quot; int divti3_test();
#ifdef HAS_COMPLEX
extern &quot;C&quot; int divxc3_test();
#endif
extern &quot;C&quot; int enable_execute_stack_test();
extern &quot;C&quot; int eqdf2vfp_test();
extern &quot;C&quot; int eqsf2vfp_test();
extern &quot;C&quot; int eqtf2_test();
extern &quot;C&quot; int extenddftf2_test();
extern &quot;C&quot; int extendhfsf2_test();
extern &quot;C&quot; int extendhftf2_test();
extern &quot;C&quot; int extendsfdf2vfp_test();
extern &quot;C&quot; int extendsftf2_test();
#if 0
extern &quot;C&quot; int gcc_personality_test();
#endif
extern &quot;C&quot; int gedf2vfp_test();
extern &quot;C&quot; int gesf2vfp_test();
extern &quot;C&quot; int getf2_test();
extern &quot;C&quot; int gtdf2vfp_test();
extern &quot;C&quot; int gtsf2vfp_test();
extern &quot;C&quot; int gttf2_test();
extern &quot;C&quot; int ledf2vfp_test();
extern &quot;C&quot; int lesf2vfp_test();
extern &quot;C&quot; int letf2_test();
extern &quot;C&quot; int lshrdi3_test();
extern &quot;C&quot; int lshrti3_test();
extern &quot;C&quot; int ltdf2vfp_test();
extern &quot;C&quot; int ltsf2vfp_test();
extern &quot;C&quot; int lttf2_test();
extern &quot;C&quot; int moddi3_test();
extern &quot;C&quot; int modsi3_test();
extern &quot;C&quot; int modst3_test();
extern &quot;C&quot; int modti3_test();
#ifdef HAS_COMPLEX
extern &quot;C&quot; int muldc3_test();
#endif
extern &quot;C&quot; int muldf3vfp_test();
extern &quot;C&quot; int muldi3_test();
extern &quot;C&quot; int mulodi4_test();
extern &quot;C&quot; int mulosi4_test();
extern &quot;C&quot; int muloti4_test();
#ifdef HAS_COMPLEX
extern &quot;C&quot; int mulsc3_test();
#endif
extern &quot;C&quot; int mulsf3vfp_test();
//extern &quot;C&quot; int mulsi3_test(); no this mulsi3.c
#ifdef HAS_COMPLEX
extern &quot;C&quot; int multc3_test();
#endif
extern &quot;C&quot; int multf3_test();
extern &quot;C&quot; int multi3_test();
extern &quot;C&quot; int mulvdi3_test();
extern &quot;C&quot; int mulvsi3_test();
extern &quot;C&quot; int mulvti3_test();
#ifdef HAS_COMPLEX
extern &quot;C&quot; int mulxc3_test();
#endif
extern &quot;C&quot; int nedf2vfp_test();
extern &quot;C&quot; int negdf2vfp_test();
extern &quot;C&quot; int negdi2_test();
extern &quot;C&quot; int negsf2vfp_test();
extern &quot;C&quot; int negti2_test();
extern &quot;C&quot; int negvdi2_test();
extern &quot;C&quot; int negvsi2_test();
extern &quot;C&quot; int negvti2_test();
extern &quot;C&quot; int nesf2vfp_test();
extern &quot;C&quot; int netf2_test();
/* need rand, signbit, ...
extern &quot;C&quot; int paritydi2_test();
extern &quot;C&quot; int paritysi2_test();
extern &quot;C&quot; int parityti2_test();
extern &quot;C&quot; int popcountdi2_test();
extern &quot;C&quot; int popcountsi2_test();
extern &quot;C&quot; int popcountti2_test();
extern &quot;C&quot; int powidf2_test();
extern &quot;C&quot; int powisf2_test();
extern &quot;C&quot; int powitf2_test();
extern &quot;C&quot; int powixf2_test();
*/
extern &quot;C&quot; int subdf3vfp_test();
extern &quot;C&quot; int subsf3vfp_test();
extern &quot;C&quot; int subtf3_test();
extern &quot;C&quot; int subvdi3_test();
extern &quot;C&quot; int subvsi3_test();
extern &quot;C&quot; int subvti3_test();
extern &quot;C&quot; int trampoline_setup_test();
extern &quot;C&quot; int truncdfhf2_test();
extern &quot;C&quot; int truncdfsf2_test();
extern &quot;C&quot; int truncdfsf2vfp_test();
extern &quot;C&quot; int truncsfhf2_test();
extern &quot;C&quot; int trunctfdf2_test();
extern &quot;C&quot; int trunctfhf2_test();
extern &quot;C&quot; int trunctfsf2_test();
extern &quot;C&quot; int ucmpdi2_test();
extern &quot;C&quot; int ucmpti2_test();
extern &quot;C&quot; int udivdi3_test();
extern &quot;C&quot; int udivmoddi4_test();
extern &quot;C&quot; int udivmodsi4_test();
extern &quot;C&quot; int udivmodti4_test();
extern &quot;C&quot; int udivsi3_test();
extern &quot;C&quot; int udivti3_test();
extern &quot;C&quot; int umoddi3_test();
extern &quot;C&quot; int umodsi3_test();
extern &quot;C&quot; int umodti3_test();
extern &quot;C&quot; int unorddf2vfp_test();
extern &quot;C&quot; int unordsf2vfp_test();
extern &quot;C&quot; int unordtf2_test();

void show_result(const char *fn, int res) {
  if (res == 1)
    printf(&quot;%s: FAIL!\n&quot;, fn);
  else if (res == 0)
    printf(&quot;%s: PASS!\n&quot;, fn);
  else if (res == -1)
    printf(&quot;%s: SKIPPED!\n&quot;, fn);
  else {
    printf(&quot;FIXME!&quot;);
    abort();
  }
}

int main() {
  int res = 0;

// pre-defined compiler macro (from llc -march=cpu0${ENDIAN} or
// clang -target cpu0${ENDIAN}-unknown-linux-gnu
#ifdef __CPU0EB__
  printf(&quot;__CPU0EB__\n&quot;);
#endif
#ifdef __CPU0EL__
  printf(&quot;__CPU0EL__\n&quot;);
#endif

  res = absvdi2_test();
  show_result(&quot;absvdi2_test()&quot;, res);

  res = absvsi2_test();
  show_result(&quot;absvsi2_test()&quot;, res);

  res = absvti2_test();
  show_result(&quot;absvti2_test()&quot;, res);

  res = adddf3vfp_test();
  show_result(&quot;adddf3vfp_test()&quot;, res);

  res = addsf3vfp_test();
  show_result(&quot;addsf3vfp_test()&quot;, res);

  res = addvdi3_test();
  show_result(&quot;addvdi3_test()&quot;, res);

  res = addvsi3_test();
  show_result(&quot;addvsi3_test()&quot;, res);

  res = addvti3_test();
  show_result(&quot;addvti3_test()&quot;, res);

  res = ashldi3_test();
  show_result(&quot;ashldi3_test()&quot;, res);

  res = ashlti3_test();
  show_result(&quot;ashlti3_test()&quot;, res);

  res = ashrdi3_test();
  show_result(&quot;ashrdi3_test()&quot;, res);

  res = ashrti3_test();
  show_result(&quot;ashrti3_test()&quot;, res);

#if 0 // atomic.c need memcmp(...)
  res = atomic_test();
  show_result(&quot;atomic_test()&quot;, res);
#endif

  res = bswapdi2_test();
  show_result(&quot;bswapdi2_test()&quot;, res);

  res = bswapsi2_test();
  show_result(&quot;bswapsi2_test()&quot;, res);

  res = clzdi2_test();
  show_result(&quot;clzdi2_test()&quot;, res);

  res = clzsi2_test();
  show_result(&quot;clzsi2_test()&quot;, res);

  res = clzti2_test();
  show_result(&quot;clzti2_test()&quot;, res);

  res = cmpdi2_test();
  show_result(&quot;cmpdi2_test()&quot;, res);

  res = cmpti2_test();
  show_result(&quot;cmpti2_test()&quot;, res);

  res = comparedf2_test();
  show_result(&quot;comparedf2_test()&quot;, res);

  res = comparesf2_test();
  show_result(&quot;comparesf2_test()&quot;, res);

//  res = compiler_rt_logb_test();
//  show_result(&quot;compiler_rt_logb_test()&quot;, res);

//  res = compiler_rt_logbf_test();
//  show_result(&quot;compiler_rt_logbf_test()&quot;, res);

//  res = compiler_rt_logbl_test();
//  show_result(&quot;compiler_rt_logbl_test()&quot;, res);

  res = cpu_model_test();
  show_result(&quot;cpu_model_test()&quot;, res);

  res = ctzdi2_test();
  show_result(&quot;ctzdi2_test()&quot;, res);

  res = ctzsi2_test();
  show_result(&quot;ctzsi2_test()&quot;, res);

  res = ctzti2_test();
  show_result(&quot;ctzti2_test()&quot;, res);

#ifdef HAS_COMPLEX
  res = divdc3_test();
  show_result(&quot;divdc3_test()&quot;, res);
#endif

  res = divdf3_test();
  show_result(&quot;divdf3_test()&quot;, res);

  res = divdf3vfp_test();
  show_result(&quot;divdf3vfp_test()&quot;, res);

  res = divdi3_test();
  show_result(&quot;divdi3_test()&quot;, res);

  res = divmodsi4_test();
  show_result(&quot;divmodsi4_test()&quot;, res);

  res = divmodti4_test();
  show_result(&quot;divmodti4_test()&quot;, res);

#ifdef HAS_COMPLEX
  res = divsc3_test();
  show_result(&quot;divsc3_test()&quot;, res);
#endif

  res = divsf3_test();
  show_result(&quot;divsf3_test()&quot;, res);

  res = divsf3vfp_test();
  show_result(&quot;divsf3vfp_test()&quot;, res);

  res = divsi3_test();
  show_result(&quot;divsi3_test()&quot;, res);

#ifdef HAS_COMPLEX
  res = divtc3_test();
  show_result(&quot;divtc3_test()&quot;, res);
#endif

  res = divtf3_test();
  show_result(&quot;divtf3_test()&quot;, res);

  res = divti3_test();
  show_result(&quot;divti3_test()&quot;, res);

#ifdef HAS_COMPLEX
  res = divxc3_test();
  show_result(&quot;divxc3_test()&quot;, res);
#endif

#if 0
  res = enable_execute_stack_test();
  show_result(&quot;enable_execute_stack_test()&quot;, res);
#endif

  res = eqdf2vfp_test();
  show_result(&quot;eqdf2vfp_test()&quot;, res);

  res = eqsf2vfp_test();
  show_result(&quot;eqsf2vfp_test()&quot;, res);

  res = eqtf2_test();
  show_result(&quot;eqtf2_test()&quot;, res);

  res = extenddftf2_test();
  show_result(&quot;extenddftf2_test()&quot;, res);

  res = extendhfsf2_test();
  show_result(&quot;extendhfsf2_test()&quot;, res);

  res = extendhftf2_test();
  show_result(&quot;extendhftf2_test()&quot;, res);

  res = extendsfdf2vfp_test();
  show_result(&quot;extendsfdf2vfp_test()&quot;, res);

  res = extendsftf2_test();
  show_result(&quot;extendsftf2_test()&quot;, res);

#if 0
  res = gcc_personality_test();
  show_result(&quot;gcc_personality_test()&quot;, res);
#endif

  res = gedf2vfp_test();
  show_result(&quot;gedf2vfp_test()&quot;, res);

  res = gesf2vfp_test();
  show_result(&quot;gesf2vfp_test()&quot;, res);

  res = getf2_test();
  show_result(&quot;getf2_test()&quot;, res);

  res = gtdf2vfp_test();
  show_result(&quot;gtdf2vfp_test()&quot;, res);

  res = gtsf2vfp_test();
  show_result(&quot;gtsf2vfp_test()&quot;, res);

  res = gttf2_test();
  show_result(&quot;gttf2_test()&quot;, res);

  res = ledf2vfp_test();
  show_result(&quot;ledf2vfp_test()&quot;, res);

  res = lesf2vfp_test();
  show_result(&quot;lesf2vfp_test()&quot;, res);

  res = letf2_test();
  show_result(&quot;letf2_test()&quot;, res);

  res = lshrdi3_test();
  show_result(&quot;lshrdi3_test()&quot;, res);

  res = lshrti3_test();
  show_result(&quot;lshrti3_test()&quot;, res);

  res = ltdf2vfp_test();
  show_result(&quot;ltdf2vfp_test()&quot;, res);

  res = ltsf2vfp_test();
  show_result(&quot;ltsf2vfp_test()&quot;, res);

  res = lttf2_test();
  show_result(&quot;lttf2_test()&quot;, res);

  res = moddi3_test();
  show_result(&quot;moddi3_test()&quot;, res);

  res = modsi3_test();
  show_result(&quot;modsi3_test()&quot;, res);

  res = modti3_test();
  show_result(&quot;modti3_test()&quot;, res);

#ifdef HAS_COMPLEX
  res = muldc3_test();
  show_result(&quot;muldc3_test()&quot;, res);
#endif

  res = muldf3vfp_test();
  show_result(&quot;muldf3vfp_test()&quot;, res);

  res = muldi3_test();
  show_result(&quot;muldi3_test()&quot;, res);

  res = mulodi4_test();
  show_result(&quot;mulodi4_test()&quot;, res);

  res = mulosi4_test();
  show_result(&quot;mulosi4_test()&quot;, res);

  res = muloti4_test();
  show_result(&quot;muloti4_test()&quot;, res);

#ifdef HAS_COMPLEX
  res = mulsc3_test();
  show_result(&quot;mulsc3_test()&quot;, res);
#endif

  res = mulsf3vfp_test();
  show_result(&quot;mulsf3vfp_test()&quot;, res);

// no mulsi3.c
//  res = mulsi3_test();
//  show_result(&quot;mulsi3_test()&quot;, res);

#ifdef HAS_COMPLEX
  res = multc3_test();
  show_result(&quot;multc3_test()&quot;, res);
#endif

  res = multf3_test();
  show_result(&quot;multf3_test()&quot;, res);

  res = multi3_test();
  show_result(&quot;multi3_test()&quot;, res);

  res = mulvdi3_test();
  show_result(&quot;mulvdi3_test()&quot;, res);

  res = mulvsi3_test();
  show_result(&quot;mulvsi3_test()&quot;, res);

  res = mulvti3_test();
  show_result(&quot;mulvti3_test()&quot;, res);

#ifdef HAS_COMPLEX
  res = mulxc3_test();
  show_result(&quot;mulxc3_test()&quot;, res);
#endif

  res = nedf2vfp_test();
  show_result(&quot;nedf2vfp_test()&quot;, res);

  res = negdf2vfp_test();
  show_result(&quot;negdf2vfp_test()&quot;, res);

  res = negdi2_test();
  show_result(&quot;negdi2_test()&quot;, res);

  res = negsf2vfp_test();
  show_result(&quot;negsf2vfp_test()&quot;, res);

  res = negti2_test();
  show_result(&quot;negti2_test()&quot;, res);

  res = negvdi2_test();
  show_result(&quot;negvdi2_test()&quot;, res);

  res = negvsi2_test();
  show_result(&quot;negvsi2_test()&quot;, res);

  res = negvti2_test();
  show_result(&quot;negvti2_test()&quot;, res);

  res = nesf2vfp_test();
  show_result(&quot;nesf2vfp_test()&quot;, res);

  res = netf2_test();
  show_result(&quot;netf2_test()&quot;, res);

/* need rand, signbit, ...
  res = paritydi2_test();
  show_result(&quot;paritydi2_test()&quot;, res);

  res = paritysi2_test();
  show_result(&quot;paritysi2_test()&quot;, res);

  res = parityti2_test();
  show_result(&quot;parityti2_test()&quot;, res);

  res = popcountdi2_test();
  show_result(&quot;popcountdi2_test()&quot;, res);

  res = popcountsi2_test();
  show_result(&quot;popcountsi2_test()&quot;, res);

  res = popcountti2_test();
  show_result(&quot;popcountti2_test()&quot;, res);

  res = powidf2_test();
  show_result(&quot;powidf2_test()&quot;, res);

  res = powisf2_test();
  show_result(&quot;powisf2_test()&quot;, res);

  res = powitf2_test();
  show_result(&quot;powitf2_test()&quot;, res);

  res = powixf2_test();
  show_result(&quot;powixf2_test()&quot;, res);
*/

  res = subdf3vfp_test();
  show_result(&quot;subdf3vfp_test()&quot;, res);

  res = subsf3vfp_test();
  show_result(&quot;subsf3vfp_test()&quot;, res);

  res = subtf3_test();
  show_result(&quot;subtf3_test()&quot;, res);

  res = subvdi3_test();
  show_result(&quot;subvdi3_test()&quot;, res);

  res = subvsi3_test();
  show_result(&quot;subvsi3_test()&quot;, res);

  res = subvti3_test();
  show_result(&quot;subvti3_test()&quot;, res);

  res = trampoline_setup_test();
  show_result(&quot;trampoline_setup_test()&quot;, res);

  res = truncdfhf2_test();
  show_result(&quot;truncdfhf2_test()&quot;, res);

  res = truncdfsf2_test();
  show_result(&quot;truncdfsf2_test()&quot;, res);

  res = truncdfsf2vfp_test();
  show_result(&quot;truncdfsf2vfp_test()&quot;, res);

  res = truncsfhf2_test();
  show_result(&quot;truncsfhf2_test()&quot;, res);

  res = trunctfdf2_test();
  show_result(&quot;trunctfdf2_test()&quot;, res);

  res = trunctfhf2_test();
  show_result(&quot;trunctfhf2_test()&quot;, res);

  res = trunctfsf2_test();
  show_result(&quot;trunctfsf2_test()&quot;, res);

  res = ucmpdi2_test();
  show_result(&quot;ucmpdi2_test()&quot;, res);

  res = ucmpti2_test();
  show_result(&quot;ucmpti2_test()&quot;, res);

  res = udivdi3_test();
  show_result(&quot;udivdi3_test()&quot;, res);

  res = udivmoddi4_test();
  show_result(&quot;udivmoddi4_test()&quot;, res);

  res = udivmodsi4_test();
  show_result(&quot;udivmodsi4_test()&quot;, res);

  res = udivmodti4_test();
  show_result(&quot;udivmodti4_test()&quot;, res);

  res = udivsi3_test();
  show_result(&quot;udivsi3_test()&quot;, res);

  res = udivti3_test();
  show_result(&quot;udivti3_test()&quot;, res);

  res = umoddi3_test();
  show_result(&quot;umoddi3_test()&quot;, res);

  res = umodsi3_test();
  show_result(&quot;umodsi3_test()&quot;, res);

  res = umodti3_test();
  show_result(&quot;umodti3_test()&quot;, res);

  res = unorddf2vfp_test();
  show_result(&quot;unorddf2vfp_test()&quot;, res);

  res = unordsf2vfp_test();
  show_result(&quot;unordsf2vfp_test()&quot;, res);

  res = unordtf2_test();
  show_result(&quot;unordtf2_test()&quot;, res);

  return 0;
}

</pre></div>
</div>
<p class="rubric">exlbt/input/Makefile.builtins</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span># CPU and endian passed from command line, such as 
#   &quot;make -f Makefile.builtins CPU=cpu032II ENDIAN=eb \

# start.cpp must be put at beginning
SRCS :=  start.cpp debug.cpp syscalls.c sanitizer_printf.cpp printf-stdarg-def.c \
  compiler-rt-test/builtins/Unit/absvdi2_test.c \
  compiler-rt-test/builtins/Unit/absvsi2_test.c \
  compiler-rt-test/builtins/Unit/absvti2_test.c \
  compiler-rt-test/builtins/Unit/adddf3vfp_test.c \
  compiler-rt-test/builtins/Unit/addsf3vfp_test.c \
  compiler-rt-test/builtins/Unit/addvdi3_test.c \
  compiler-rt-test/builtins/Unit/addvsi3_test.c \
  compiler-rt-test/builtins/Unit/addvti3_test.c \
  compiler-rt-test/builtins/Unit/ashldi3_test.c \
  compiler-rt-test/builtins/Unit/ashlti3_test.c \
  compiler-rt-test/builtins/Unit/ashrdi3_test.c \
  compiler-rt-test/builtins/Unit/ashrti3_test.c \
  compiler-rt-test/builtins/Unit/bswapdi2_test.c \
  compiler-rt-test/builtins/Unit/bswapsi2_test.c \
  compiler-rt-test/builtins/Unit/clzdi2_test.c \
  compiler-rt-test/builtins/Unit/clzsi2_test.c \
  compiler-rt-test/builtins/Unit/clzti2_test.c \
  compiler-rt-test/builtins/Unit/cmpdi2_test.c \
  compiler-rt-test/builtins/Unit/cmpti2_test.c \
  compiler-rt-test/builtins/Unit/comparedf2_test.c \
  compiler-rt-test/builtins/Unit/comparesf2_test.c \
  compiler-rt-test/builtins/Unit/cpu_model_test.c \
  compiler-rt-test/builtins/Unit/ctzdi2_test.c \
  compiler-rt-test/builtins/Unit/ctzsi2_test.c \
  compiler-rt-test/builtins/Unit/ctzti2_test.c \
  compiler-rt-test/builtins/Unit/divdc3_test.c \
  compiler-rt-test/builtins/Unit/divdf3_test.c \
  compiler-rt-test/builtins/Unit/divdf3vfp_test.c \
  compiler-rt-test/builtins/Unit/divdi3_test.c \
  compiler-rt-test/builtins/Unit/divmodsi4_test.c \
  compiler-rt-test/builtins/Unit/divmodti4_test.c \
  compiler-rt-test/builtins/Unit/divsc3_test.c \
  compiler-rt-test/builtins/Unit/divsf3_test.c \
  compiler-rt-test/builtins/Unit/divsf3vfp_test.c \
  compiler-rt-test/builtins/Unit/divsi3_test.c \
  compiler-rt-test/builtins/Unit/divtc3_test.c \
  compiler-rt-test/builtins/Unit/divtf3_test.c \
  compiler-rt-test/builtins/Unit/divti3_test.c \
  compiler-rt-test/builtins/Unit/divxc3_test.c \
  compiler-rt-test/builtins/Unit/enable_execute_stack_test.c \
  compiler-rt-test/builtins/Unit/eqdf2vfp_test.c \
  compiler-rt-test/builtins/Unit/eqsf2vfp_test.c \
  compiler-rt-test/builtins/Unit/eqtf2_test.c \
  compiler-rt-test/builtins/Unit/extenddftf2_test.c \
  compiler-rt-test/builtins/Unit/extendhfsf2_test.c \
  compiler-rt-test/builtins/Unit/extendhftf2_test.c \
  compiler-rt-test/builtins/Unit/extendsfdf2vfp_test.c \
  compiler-rt-test/builtins/Unit/extendsftf2_test.c \
  compiler-rt-test/builtins/Unit/gedf2vfp_test.c \
  compiler-rt-test/builtins/Unit/gesf2vfp_test.c \
  compiler-rt-test/builtins/Unit/getf2_test.c \
  compiler-rt-test/builtins/Unit/gtdf2vfp_test.c \
  compiler-rt-test/builtins/Unit/gtsf2vfp_test.c \
  compiler-rt-test/builtins/Unit/gttf2_test.c \
  compiler-rt-test/builtins/Unit/ledf2vfp_test.c \
  compiler-rt-test/builtins/Unit/lesf2vfp_test.c \
  compiler-rt-test/builtins/Unit/letf2_test.c \
  compiler-rt-test/builtins/Unit/lshrdi3_test.c \
  compiler-rt-test/builtins/Unit/lshrti3_test.c \
  compiler-rt-test/builtins/Unit/ltdf2vfp_test.c \
  compiler-rt-test/builtins/Unit/ltsf2vfp_test.c \
  compiler-rt-test/builtins/Unit/lttf2_test.c \
  compiler-rt-test/builtins/Unit/moddi3_test.c \
  compiler-rt-test/builtins/Unit/modsi3_test.c \
  compiler-rt-test/builtins/Unit/modti3_test.c \
  compiler-rt-test/builtins/Unit/muldc3_test.c \
  compiler-rt-test/builtins/Unit/muldf3vfp_test.c \
  compiler-rt-test/builtins/Unit/muldi3_test.c \
  compiler-rt-test/builtins/Unit/mulodi4_test.c \
  compiler-rt-test/builtins/Unit/mulosi4_test.c \
  compiler-rt-test/builtins/Unit/muloti4_test.c \
  compiler-rt-test/builtins/Unit/mulsc3_test.c \
  compiler-rt-test/builtins/Unit/mulsf3vfp_test.c \
  compiler-rt-test/builtins/Unit/mulsi3_test.c \
  compiler-rt-test/builtins/Unit/multc3_test.c \
  compiler-rt-test/builtins/Unit/multf3_test.c \
  compiler-rt-test/builtins/Unit/multi3_test.c \
  compiler-rt-test/builtins/Unit/mulvdi3_test.c \
  compiler-rt-test/builtins/Unit/mulvsi3_test.c \
  compiler-rt-test/builtins/Unit/mulvti3_test.c \
  compiler-rt-test/builtins/Unit/mulxc3_test.c \
  compiler-rt-test/builtins/Unit/nedf2vfp_test.c \
  compiler-rt-test/builtins/Unit/negdf2vfp_test.c \
  compiler-rt-test/builtins/Unit/negdi2_test.c \
  compiler-rt-test/builtins/Unit/negsf2vfp_test.c \
  compiler-rt-test/builtins/Unit/negti2_test.c \
  compiler-rt-test/builtins/Unit/negvdi2_test.c \
  compiler-rt-test/builtins/Unit/negvsi2_test.c \
  compiler-rt-test/builtins/Unit/negvti2_test.c \
  compiler-rt-test/builtins/Unit/nesf2vfp_test.c \
  compiler-rt-test/builtins/Unit/netf2_test.c \
  compiler-rt-test/builtins/Unit/paritydi2_test.c \
  compiler-rt-test/builtins/Unit/paritysi2_test.c \
  compiler-rt-test/builtins/Unit/parityti2_test.c \
  compiler-rt-test/builtins/Unit/popcountdi2_test.c \
  compiler-rt-test/builtins/Unit/popcountsi2_test.c \
  compiler-rt-test/builtins/Unit/popcountti2_test.c \
  compiler-rt-test/builtins/Unit/powidf2_test.c \
  compiler-rt-test/builtins/Unit/powisf2_test.c \
  compiler-rt-test/builtins/Unit/powitf2_test.c \
  compiler-rt-test/builtins/Unit/powixf2_test.c \
  compiler-rt-test/builtins/Unit/subdf3vfp_test.c \
  compiler-rt-test/builtins/Unit/subsf3vfp_test.c \
  compiler-rt-test/builtins/Unit/subtf3_test.c \
  compiler-rt-test/builtins/Unit/subvdi3_test.c \
  compiler-rt-test/builtins/Unit/subvsi3_test.c \
  compiler-rt-test/builtins/Unit/subvti3_test.c \
  compiler-rt-test/builtins/Unit/trampoline_setup_test.c \
  compiler-rt-test/builtins/Unit/truncdfhf2_test.c \
  compiler-rt-test/builtins/Unit/truncdfsf2_test.c \
  compiler-rt-test/builtins/Unit/truncdfsf2vfp_test.c \
  compiler-rt-test/builtins/Unit/truncsfhf2_test.c \
  compiler-rt-test/builtins/Unit/trunctfdf2_test.c \
  compiler-rt-test/builtins/Unit/trunctfhf2_test.c \
  compiler-rt-test/builtins/Unit/trunctfsf2_test.c \
  compiler-rt-test/builtins/Unit/ucmpdi2_test.c \
  compiler-rt-test/builtins/Unit/ucmpti2_test.c \
  compiler-rt-test/builtins/Unit/udivdi3_test.c \
  compiler-rt-test/builtins/Unit/udivmoddi4_test.c \
  compiler-rt-test/builtins/Unit/udivmodsi4_test.c \
  compiler-rt-test/builtins/Unit/udivmodti4_test.c \
  compiler-rt-test/builtins/Unit/udivsi3_test.c \
  compiler-rt-test/builtins/Unit/udivti3_test.c \
  compiler-rt-test/builtins/Unit/umoddi3_test.c \
  compiler-rt-test/builtins/Unit/umodsi3_test.c \
  compiler-rt-test/builtins/Unit/umodti3_test.c \
  compiler-rt-test/builtins/Unit/unorddf2vfp_test.c \
  compiler-rt-test/builtins/Unit/unordsf2vfp_test.c \
  compiler-rt-test/builtins/Unit/unordtf2_test.c \
  cpu0-builtins.cpp ch_builtins.cpp lib_cpu0.c

INC_DIRS := ./ $(LBDEX_DIR)/input \
            $(HOME)/llvm/llvm-project/compiler-rt/lib/builtins \
            $(NEWLIB_DIR)/newlib/libc/include \
            $(NEWLIB_DIR)/libgloss 
LIBBUILTINS_DIR := ../compiler-rt/builtins
LIBS := $(LIBBUILTINS_DIR)/build-$(CPU)-$(ENDIAN)/libbuiltins.a \
        $(NEWLIB_DIR)/build-$(CPU)-$(ENDIAN)/libm.a \
        $(NEWLIB_DIR)/build-$(CPU)-$(ENDIAN)/libc.a

include Common.mk
</pre></div>
</div>
<p>Run as follows,</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">chungshu@ChungShudeMacBook-Air input % </span>bash make.sh cpu032II eb Makefile.builtins
<span class="go">...</span>
<span class="gp">chungshu@ChungShudeMacBook-Air verilog % </span>./cpu0IIs
<span class="go">...</span>
<span class="go">absvdi2_test(): PASS!</span>
<span class="go">absvsi2_test(): PASS!</span>
<span class="go">absvti2_test(): SKIPPED!</span>
<span class="go">adddf3vfp_test(): SKIPPED!</span>
<span class="go">addsf3vfp_test(): SKIPPED!</span>
<span class="go">addvdi3_test(): PASS!</span>
<span class="go">addvsi3_test(): PASS!</span>
<span class="go">addvti3_test(): SKIPPED!</span>
<span class="go">ashldi3_test(): PASS!</span>
<span class="go">ashlti3_test(): SKIPPED!</span>
<span class="go">ashrdi3_test(): PASS!</span>
<span class="go">ashrti3_test(): SKIPPED!</span>
<span class="go">bswapdi2_test(): PASS!</span>
<span class="go">bswapsi2_test(): PASS!</span>
<span class="go">clzdi2_test(): PASS!</span>
<span class="go">clzsi2_test(): PASS!</span>
<span class="go">clzti2_test(): SKIPPED!</span>
<span class="go">cmpdi2_test(): PASS!</span>
<span class="go">cmpti2_test(): SKIPPED!</span>
<span class="go">comparedf2_test(): PASS!</span>
<span class="go">comparesf2_test(): PASS!</span>
<span class="go">cpu_model_test(): SKIPPED!</span>
<span class="go">ctzdi2_test(): PASS!</span>
<span class="go">ctzsi2_test(): PASS!</span>
<span class="go">ctzti2_test(): SKIPPED!</span>
<span class="go">divdc3_test(): PASS!</span>
<span class="go">divdf3_test(): PASS!</span>
<span class="go">divdf3vfp_test(): SKIPPED!</span>
<span class="go">divdi3_test(): PASS!</span>
<span class="go">divmodsi4_test(): PASS!</span>
<span class="go">divmodti4_test(): SKIPPED!</span>
<span class="go">divsf3_test(): PASS!</span>
<span class="go">divsf3vfp_test(): SKIPPED!</span>
<span class="go">divsi3_test(): PASS!</span>
<span class="go">divtc3_test(): PASS!</span>
<span class="go">divtf3_test(): SKIPPED!</span>
<span class="go">divti3_test(): SKIPPED!</span>
<span class="go">divxc3_test(): PASS!</span>
<span class="go">eqdf2vfp_test(): SKIPPED!</span>
<span class="go">eqsf2vfp_test(): SKIPPED!</span>
<span class="go">eqtf2_test(): SKIPPED!</span>
<span class="go">extenddftf2_test(): SKIPPED!</span>
<span class="go">extendhfsf2_test(): PASS!</span>
<span class="go">extendhftf2_test(): SKIPPED!</span>
<span class="go">extendsfdf2vfp_test(): SKIPPED!</span>
<span class="go">extendsftf2_test(): SKIPPED!</span>
<span class="go">gedf2vfp_test(): SKIPPED!</span>
<span class="go">gesf2vfp_test(): SKIPPED!</span>
<span class="go">getf2_test(): SKIPPED!</span>
<span class="go">gtdf2vfp_test(): SKIPPED!</span>
<span class="go">gtsf2vfp_test(): SKIPPED!</span>
<span class="go">gttf2_test(): SKIPPED!</span>
<span class="go">ledf2vfp_test(): SKIPPED!</span>
<span class="go">lesf2vfp_test(): SKIPPED!</span>
<span class="go">letf2_test(): SKIPPED!</span>
<span class="go">lshrdi3_test(): PASS!</span>
<span class="go">lshrti3_test(): SKIPPED!</span>
<span class="go">ltdf2vfp_test(): SKIPPED!</span>
<span class="go">ltsf2vfp_test(): SKIPPED!</span>
<span class="go">lttf2_test(): SKIPPED!</span>
<span class="go">moddi3_test(): PASS!</span>
<span class="go">modsi3_test(): PASS!</span>
<span class="go">modti3_test(): SKIPPED!</span>
<span class="go">muldc3_test(): PASS!</span>
<span class="go">muldf3vfp_test(): SKIPPED!</span>
<span class="go">muldi3_test(): PASS!</span>
<span class="go">mulodi4_test(): PASS!</span>
<span class="go">mulosi4_test(): PASS!</span>
<span class="go">muloti4_test(): SKIPPED!</span>
<span class="go">mulsc3_test(): PASS!</span>
<span class="go">mulsf3vfp_test(): SKIPPED!</span>
<span class="go">multc3_test(): SKIPPED!</span>
<span class="go">multf3_test(): SKIPPED!</span>
<span class="go">multi3_test(): SKIPPED!</span>
<span class="go">mulvdi3_test(): PASS!</span>
<span class="go">mulvsi3_test(): PASS!</span>
<span class="go">mulvti3_test(): SKIPPED!</span>
<span class="go">mulxc3_test(): PASS!</span>
<span class="go">nedf2vfp_test(): SKIPPED!</span>
<span class="go">negdf2vfp_test(): SKIPPED!</span>
<span class="go">negdi2_test(): PASS!</span>
<span class="go">negsf2vfp_test(): SKIPPED!</span>
<span class="go">negti2_test(): SKIPPED!</span>
<span class="go">negvdi2_test(): PASS!</span>
<span class="go">negvsi2_test(): PASS!</span>
<span class="go">negvti2_test(): SKIPPED!</span>
<span class="go">nesf2vfp_test(): SKIPPED!</span>
<span class="go">netf2_test(): SKIPPED!</span>
<span class="go">subdf3vfp_test(): SKIPPED!</span>
<span class="go">subsf3vfp_test(): SKIPPED!</span>
<span class="go">subtf3_test(): SKIPPED!</span>
<span class="go">subvdi3_test(): PASS!</span>
<span class="go">subvsi3_test(): PASS!</span>
<span class="go">subvti3_test(): SKIPPED!</span>
<span class="go">trampoline_setup_test(): SKIPPED!</span>
<span class="go">truncdfhf2_test(): PASS!</span>
<span class="go">truncdfsf2_test(): PASS!</span>
<span class="go">truncdfsf2vfp_test(): SKIPPED!</span>
<span class="go">truncsfhf2_test(): PASS!</span>
<span class="go">trunctfdf2_test(): SKIPPED!</span>
<span class="go">trunctfhf2_test(): SKIPPED!</span>
<span class="go">trunctfsf2_test(): SKIPPED!</span>
<span class="go">ucmpdi2_test(): PASS!</span>
<span class="go">ucmpti2_test(): SKIPPED!</span>
<span class="go">udivdi3_test(): PASS!</span>
<span class="go">udivmoddi4_test(): PASS!</span>
<span class="go">udivmodsi4_test(): PASS!</span>
<span class="go">udivmodti4_test(): SKIPPED!</span>
<span class="go">udivsi3_test(): PASS!</span>
<span class="go">udivti3_test(): SKIPPED!</span>
<span class="go">umoddi3_test(): PASS!</span>
<span class="go">umodsi3_test(): PASS!</span>
<span class="go">umodti3_test(): SKIPPED!</span>
<span class="go">unorddf2vfp_test(): SKIPPED!</span>
<span class="go">unordsf2vfp_test(): SKIPPED!</span>
<span class="go">unordtf2_test(): SKIPPED!</span>
<span class="go">...</span>
<span class="go">RET to PC &lt; 0, finished!</span>
</pre></div>
</div>
<dl class="footnote brackets">
<dt class="label" id="newlib"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p><a class="reference external" href="https://sourceware.org/newlib/">https://sourceware.org/newlib/</a></p>
</dd>
<dt class="label" id="newlib-libm"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p><a class="reference external" href="https://sourceware.org/newlib/libm.html">https://sourceware.org/newlib/libm.html</a></p>
</dd>
<dt class="label" id="id11"><span class="brackets"><a class="fn-backref" href="#id3">3</a></span></dt>
<dd><p><a class="reference external" href="http://compiler-rt.llvm.org/">http://compiler-rt.llvm.org/</a></p>
</dd>
<dt class="label" id="builtins-readme"><span class="brackets"><a class="fn-backref" href="#id4">4</a></span></dt>
<dd><p><a class="reference external" href="https://github.com/llvm-mirror/compiler-rt/blob/master/lib/builtins/README.txt">https://github.com/llvm-mirror/compiler-rt/blob/master/lib/builtins/README.txt</a></p>
</dd>
<dt class="label" id="builtins-int-math"><span class="brackets"><a class="fn-backref" href="#id5">5</a></span></dt>
<dd><p><a class="reference external" href="https://github.com/microsoft/compiler-rt/blob/master/lib/builtins/int_math.h">https://github.com/microsoft/compiler-rt/blob/master/lib/builtins/int_math.h</a></p>
</dd>
<dt class="label" id="lib-gcc"><span class="brackets"><a class="fn-backref" href="#id6">6</a></span></dt>
<dd><p><a class="reference external" href="https://gcc.gnu.org/onlinedocs/gccint/Libgcc.html">https://gcc.gnu.org/onlinedocs/gccint/Libgcc.html</a></p>
</dd>
<dt class="label" id="int-lib"><span class="brackets"><a class="fn-backref" href="#id7">7</a></span></dt>
<dd><p><a class="reference external" href="https://gcc.gnu.org/onlinedocs/gccint/Integer-library-routines.html#Integer-library-routines">https://gcc.gnu.org/onlinedocs/gccint/Integer-library-routines.html#Integer-library-routines</a></p>
</dd>
<dt class="label" id="sw-float-lib"><span class="brackets"><a class="fn-backref" href="#id8">8</a></span></dt>
<dd><p><a class="reference external" href="https://gcc.gnu.org/onlinedocs/gccint/Soft-float-library-routines.html#Soft-float-library-routines">https://gcc.gnu.org/onlinedocs/gccint/Soft-float-library-routines.html#Soft-float-library-routines</a></p>
</dd>
<dt class="label" id="math"><span class="brackets"><a class="fn-backref" href="#id9">9</a></span></dt>
<dd><p><a class="reference external" href="https://www.programiz.com/c-programming/library-function/math.h">https://www.programiz.com/c-programming/library-function/math.h</a></p>
</dd>
<dt class="label" id="clib"><span class="brackets"><a class="fn-backref" href="#id10">10</a></span></dt>
<dd><p><a class="reference external" href="https://www.cplusplus.com/reference/clibrary">https://www.cplusplus.com/reference/clibrary</a></p>
</dd>
</dl>
</section>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="opt.html">Optimization</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="lldb.html">LLDB</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Chen Chung-Shu.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.4.0.
    </div>
  </body>
</html>