
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Cpu0 ELF linker &#8212; Tutorial: Creating an LLVM Toolchain for the Cpu0 Architecture</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/haiku.css" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Optimization" href="opt.html" />
    <link rel="prev" title="Clang" href="clang.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>Tutorial: Creating an LLVM Toolchain for the Cpu0 Architecture</span></a></h1>
        <h2 class="heading"><span>Cpu0 ELF linker</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="clang.html">Clang</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="opt.html">Optimization</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <section id="cpu0-elf-linker">
<span id="sec-lld"></span><h1>Cpu0 ELF linker<a class="headerlink" href="#cpu0-elf-linker" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#elf-to-hex" id="id17">ELF to Hex</a></p></li>
<li><p><a class="reference internal" href="#create-cpu0-backend-under-lld" id="id18">Create Cpu0 backend under LLD</a></p>
<ul>
<li><p><a class="reference internal" href="#lld-introduction" id="id19">LLD introduction</a></p></li>
<li><p><a class="reference internal" href="#static-linker" id="id20">Static linker</a></p></li>
<li><p><a class="reference internal" href="#dynamic-linker" id="id21">Dynamic linker</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#summary" id="id22">Summary</a></p>
<ul>
<li><p><a class="reference internal" href="#create-a-new-backend-base-on-llvm" id="id23">Create a new backend base on LLVM</a></p></li>
<li><p><a class="reference internal" href="#contribute-back-to-open-source-through-working-and-learning" id="id24">Contribute back to Open Source through working and learning</a></p></li>
</ul>
</li>
</ul>
</div>
<p>LLD changes quickly and the figures of this chapter is not up to date.
Like llvm, lld linker include a couple of target in ELF format handling.
The term Cpu0 backend used in this chapter can refer to the ELF format handling
for Cpu0 target machine under lld, llvm compiler backend, or both. But
supposing readers will easy knowing what it refer to.</p>
<figure class="align-center" id="id15">
<span id="lld-f-workflow"></span><a class="reference internal image-reference" href="_images/mywork_1.png"><img alt="_images/mywork_1.png" src="_images/mywork_1.png" style="width: 1194.0px; height: 411.0px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 3 </span><span class="caption-text">Code generation and execution flow</span><a class="headerlink" href="#id15" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>As depicted in <a class="reference internal" href="#lld-f-workflow"><span class="std std-numref">Fig. 3</span></a> of chapter About. Beside llvm backend,
we implement ELF linker and elf2hex to run on Cpu0 verilog simulator.
This chapter extends lld to support Cpu0 backend as well as elf2hex to replace
Cpu0 loader.
After link with lld,
the program with global variables can be allocated in ELF file format layout.
Meaning the relocation records of global variables is resolved. In addition,
elf2hex is implemented for supporting generate Hex file from ELF.
With these two tools supported, the global variables exists in
section .data and .rodata can be accessed and transfered to Hex file which feeds
to Verilog Cpu0 machine and run on your PC/Laptop.</p>
<p>As the previouse chapters mentioned, Cpu0 has two relocation models for static
link and dynamic link, respectively, which controlled by option
<code class="docutils literal notranslate"><span class="pre">-relocation-model</span></code> in <code class="docutils literal notranslate"><span class="pre">llc</span></code>.
This chapter supports the static link.</p>
<p>About lld please refer LLD web site here <a class="footnote-reference brackets" href="#lldweb" id="id1">1</a> and LLD install requirement
on Linux here <a class="footnote-reference brackets" href="#lld-install" id="id2">2</a>.
Currently, lld can be built by: gcc and clang compiler on Ubuntu.
On iMac, lld can be built by clang with the Xcode version as the next sub
section.
If you run with Virtual Machine (VM), please keep your phisical memory size
setting over 1GB to avoid insufficient memory link error.</p>
<section id="elf-to-hex">
<h2><a class="toc-backref" href="#id17">ELF to Hex</a><a class="headerlink" href="#elf-to-hex" title="Permalink to this headline">¶</a></h2>
<p>As follows,</p>
<p class="rubric">exlbt/elf2hex/CMakeLists.txt</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span># elf2hex.cpp needs backend related functions, like 
# LLVMInitializeCpu0TargetInfo and LLVMInitializeCpu0Disassembler ... etc.
# Set LLVM_LINK_COMPONENTS then it can link them during the link stage.
set(LLVM_LINK_COMPONENTS
#  AllTargetsAsmPrinters
  AllTargetsDescs
  AllTargetsDisassemblers
  AllTargetsInfos
  BinaryFormat
  CodeGen
  DebugInfoDWARF
  DebugInfoPDB
  Demangle
  MC
  MCDisassembler
  Object
  Support
  Symbolize
  )

add_llvm_tool(elf2hex
  elf2hex.cpp
  )

if(HAVE_LIBXAR)
  target_link_libraries(elf2hex PRIVATE ${XAR_LIB})
endif()

if(LLVM_INSTALL_BINUTILS_SYMLINKS)
  add_llvm_tool_symlink(elf2hex elf2hex)
endif()

</pre></div>
</div>
<p class="rubric">exlbt/elf2hex/elf2hex.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span>
<span class="o">//</span>                     <span class="n">The</span> <span class="n">LLVM</span> <span class="n">Compiler</span> <span class="n">Infrastructure</span>
<span class="o">//</span>
<span class="o">//</span> <span class="n">This</span> <span class="n">file</span> <span class="ow">is</span> <span class="n">distributed</span> <span class="n">under</span> <span class="n">the</span> <span class="n">University</span> <span class="n">of</span> <span class="n">Illinois</span> <span class="n">Open</span> <span class="n">Source</span>
<span class="o">//</span> <span class="n">License</span><span class="o">.</span> <span class="n">See</span> <span class="n">LICENSE</span><span class="o">.</span><span class="n">TXT</span> <span class="k">for</span> <span class="n">details</span><span class="o">.</span>
<span class="o">//</span>
<span class="o">//===----------------------------------------------------------------------===//</span>

<span class="c1">#ifndef LLVM_TOOLS_ELF2HEX_ELF2HEX_H</span>
<span class="c1">#define LLVM_TOOLS_ELF2HEX_ELF2HEX_H</span>

<span class="c1">#include &quot;llvm/DebugInfo/DIContext.h&quot;</span>
<span class="c1">#include &quot;llvm/MC/MCDisassembler/MCDisassembler.h&quot;</span>
<span class="c1">#include &quot;llvm/MC/MCInstPrinter.h&quot;</span>
<span class="c1">#include &quot;llvm/Support/CommandLine.h&quot;</span>
<span class="c1">#include &quot;llvm/Support/Compiler.h&quot;</span>
<span class="c1">#include &quot;llvm/Support/DataTypes.h&quot;</span>
<span class="c1">#include &quot;llvm/Object/Archive.h&quot;</span>

<span class="c1">#include &lt;stdio.h&gt;</span>
<span class="c1">#include &quot;llvm/Support/raw_ostream.h&quot;</span>

<span class="c1">#define BOOT_SIZE 16</span>

<span class="c1">#define DLINK</span>
<span class="o">//</span><span class="c1">#define ELF2HEX_DEBUG</span>

<span class="n">namespace</span> <span class="n">llvm</span> <span class="p">{</span>

<span class="n">namespace</span> <span class="n">elf2hex</span> <span class="p">{</span>

<span class="n">using</span> <span class="n">namespace</span> <span class="nb">object</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">HexOut</span> <span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
  <span class="n">virtual</span> <span class="n">void</span> <span class="n">ProcessDisAsmInstruction</span><span class="p">(</span><span class="n">MCInst</span> <span class="n">inst</span><span class="p">,</span> <span class="n">uint64_t</span> <span class="n">Size</span><span class="p">,</span> 
                                <span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">uint8_t</span><span class="o">&gt;</span> <span class="n">Bytes</span><span class="p">,</span> <span class="n">const</span> <span class="n">ObjectFile</span> <span class="o">*</span><span class="n">Obj</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">virtual</span> <span class="n">void</span> <span class="n">ProcessDataSection</span><span class="p">(</span><span class="n">SectionRef</span> <span class="n">Section</span><span class="p">)</span> <span class="p">{};</span>
  <span class="n">virtual</span> <span class="o">~</span><span class="n">HexOut</span><span class="p">()</span> <span class="p">{};</span>
<span class="p">};</span>

<span class="o">//</span> <span class="n">Split</span> <span class="n">HexOut</span> <span class="kn">from</span> <span class="nn">Reader</span><span class="p">::</span><span class="n">DisassembleObject</span><span class="p">()</span> <span class="k">for</span> <span class="n">separating</span> <span class="nb">hex</span> <span class="n">output</span> 
<span class="o">//</span> <span class="n">functions</span><span class="o">.</span>
<span class="k">class</span> <span class="nc">VerilogHex</span> <span class="p">:</span> <span class="n">public</span> <span class="n">HexOut</span> <span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
  <span class="n">VerilogHex</span><span class="p">(</span><span class="n">std</span><span class="p">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">MCInstPrinter</span><span class="o">&gt;&amp;</span> <span class="n">instructionPointer</span><span class="p">,</span> 
             <span class="n">std</span><span class="p">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">const</span> <span class="n">MCSubtargetInfo</span><span class="o">&gt;&amp;</span> <span class="n">subTargetInfo</span><span class="p">,</span>
             <span class="n">const</span> <span class="n">ObjectFile</span> <span class="o">*</span><span class="n">Obj</span><span class="p">);</span>
  <span class="n">void</span> <span class="n">ProcessDisAsmInstruction</span><span class="p">(</span><span class="n">MCInst</span> <span class="n">inst</span><span class="p">,</span> <span class="n">uint64_t</span> <span class="n">Size</span><span class="p">,</span> 
                                <span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">uint8_t</span><span class="o">&gt;</span> <span class="n">Bytes</span><span class="p">,</span> <span class="n">const</span> <span class="n">ObjectFile</span> <span class="o">*</span><span class="n">Obj</span><span class="p">)</span> <span class="n">override</span><span class="p">;</span>
  <span class="n">void</span> <span class="n">ProcessDataSection</span><span class="p">(</span><span class="n">SectionRef</span> <span class="n">Section</span><span class="p">)</span> <span class="n">override</span><span class="p">;</span>

<span class="n">private</span><span class="p">:</span>
  <span class="n">void</span> <span class="n">PrintBootSection</span><span class="p">(</span><span class="n">uint64_t</span> <span class="n">textOffset</span><span class="p">,</span> <span class="n">uint64_t</span> <span class="n">isrAddr</span><span class="p">,</span> <span class="nb">bool</span> <span class="n">isLittleEndian</span><span class="p">);</span>
  <span class="n">void</span> <span class="n">Fill0s</span><span class="p">(</span><span class="n">uint64_t</span> <span class="n">startAddr</span><span class="p">,</span> <span class="n">uint64_t</span> <span class="n">endAddr</span><span class="p">);</span>
  <span class="n">void</span> <span class="n">PrintDataSection</span><span class="p">(</span><span class="n">SectionRef</span> <span class="n">Section</span><span class="p">);</span>
  <span class="n">std</span><span class="p">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">MCInstPrinter</span><span class="o">&gt;&amp;</span> <span class="n">IP</span><span class="p">;</span>
  <span class="n">std</span><span class="p">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">const</span> <span class="n">MCSubtargetInfo</span><span class="o">&gt;&amp;</span> <span class="n">STI</span><span class="p">;</span>
  <span class="n">uint64_t</span> <span class="n">lastDumpAddr</span><span class="p">;</span>
  <span class="n">unsigned</span> <span class="n">si</span><span class="p">;</span>
  <span class="n">StringRef</span> <span class="n">sectionName</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Reader</span> <span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
  <span class="n">void</span> <span class="n">DisassembleObject</span><span class="p">(</span><span class="n">const</span> <span class="n">ObjectFile</span> <span class="o">*</span><span class="n">Obj</span><span class="p">,</span> 
                         <span class="n">std</span><span class="p">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">MCDisassembler</span><span class="o">&gt;&amp;</span> <span class="n">DisAsm</span><span class="p">,</span> 
                         <span class="n">std</span><span class="p">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">MCInstPrinter</span><span class="o">&gt;&amp;</span> <span class="n">IP</span><span class="p">,</span> 
                         <span class="n">std</span><span class="p">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">const</span> <span class="n">MCSubtargetInfo</span><span class="o">&gt;&amp;</span> <span class="n">STI</span><span class="p">);</span>
  <span class="n">StringRef</span> <span class="n">CurrentSymbol</span><span class="p">();</span>
  <span class="n">SectionRef</span> <span class="n">CurrentSection</span><span class="p">();</span>
  <span class="n">unsigned</span> <span class="n">CurrentSi</span><span class="p">();</span>
  <span class="n">uint64_t</span> <span class="n">CurrentIndex</span><span class="p">();</span>

<span class="n">private</span><span class="p">:</span>
  <span class="n">SectionRef</span> <span class="n">_section</span><span class="p">;</span>
  <span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="p">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">uint64_t</span><span class="p">,</span> <span class="n">StringRef</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">Symbols</span><span class="p">;</span>
  <span class="n">unsigned</span> <span class="n">si</span><span class="p">;</span>
  <span class="n">uint64_t</span> <span class="n">Index</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">}</span> <span class="o">//</span> <span class="n">end</span> <span class="n">namespace</span> <span class="n">elf2hex</span>
<span class="p">}</span> <span class="o">//</span> <span class="n">end</span> <span class="n">namespace</span> <span class="n">llvm</span>

<span class="o">//</span><span class="n">using</span> <span class="n">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="c1">#endif</span>
</pre></div>
</div>
<p class="rubric">exlbt/elf2hex/elf2hex.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>//===-- llvm-objdump.cpp - Object file dumping utility for llvm -----------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This program is a utility that works like binutils &quot;objdump&quot;, that is, it
// dumps out a plethora of information about an object file depending on the
// flags.
//
// The flags and output of this program should be near identical to those of
// binutils objdump.
//
//===----------------------------------------------------------------------===//

#define ELF2HEX

#include &quot;elf2hex.h&quot;
#include &quot;llvm/MC/MCAsmInfo.h&quot;
#include &quot;llvm/MC/MCContext.h&quot;
#include &quot;llvm/MC/MCInst.h&quot;
#include &quot;llvm/MC/MCInstrAnalysis.h&quot;
#include &quot;llvm/MC/MCInstrInfo.h&quot;
#include &quot;llvm/MC/MCObjectFileInfo.h&quot;
#include &quot;llvm/MC/MCTargetOptions.h&quot;
#include &quot;llvm/Object/MachO.h&quot;
#include &quot;llvm/Support/InitLLVM.h&quot;
#include &quot;llvm/Support/TargetRegistry.h&quot;
#include &quot;llvm/Support/TargetSelect.h&quot;

using namespace llvm;
using namespace llvm::object;

static StringRef ToolName;
static StringRef CurrInputFile;

// copy from llvm-objdump.cpp
LLVM_ATTRIBUTE_NORETURN void reportError(StringRef File,
                                                  const Twine &amp;Message) {
  outs().flush();
  WithColor::error(errs(), ToolName) &lt;&lt; &quot;&#39;&quot; &lt;&lt; File &lt;&lt; &quot;&#39;: &quot; &lt;&lt; Message &lt;&lt; &quot;\n&quot;;
  exit(1);
}

// copy from llvm-objdump.h
template &lt;typename T, typename... Ts&gt;
T unwrapOrError(Expected&lt;T&gt; EO, Ts &amp;&amp;... Args) {
  if (EO)
    return std::move(*EO);
  assert(0 &amp;&amp; &quot;error in unwrapOrError()&quot;);
}

// copy from llvm-objdump.cpp
static cl::OptionCategory Elf2hexCat(&quot;elf2hex Options&quot;);

static cl::list&lt;std::string&gt; InputFilenames(cl::Positional,
                                            cl::desc(&quot;&lt;input object files&gt;&quot;),
                                            cl::ZeroOrMore,
                                            cl::cat(Elf2hexCat));
std::string TripleName = &quot;&quot;;
                                            
static const Target *getTarget(const ObjectFile *Obj) {
  // Figure out the target triple.
  Triple TheTriple(&quot;unknown-unknown-unknown&quot;);
  TheTriple = Obj-&gt;makeTriple();

  // Get the target specific parser.
  std::string Error;
  const Target *TheTarget = TargetRegistry::lookupTarget(&quot;&quot;, TheTriple,
                                                         Error);
  if (!TheTarget)
    reportError(Obj-&gt;getFileName(), &quot;can&#39;t find target: &quot; + Error);

  // Update the triple name and return the found target.
  TripleName = TheTriple.getTriple();
  return TheTarget;
}

bool isRelocAddressLess(RelocationRef A, RelocationRef B) {
  return A.getOffset() &lt; B.getOffset();
}

void error(std::error_code EC) {
  if (!EC)
    return;
  WithColor::error(errs(), ToolName)
      &lt;&lt; &quot;reading file: &quot; &lt;&lt; EC.message() &lt;&lt; &quot;.\n&quot;;
  errs().flush();
  exit(1);
}

static void getName(llvm::object::SectionRef const &amp;Section, StringRef Name) {
  Name = unwrapOrError(Section.getName(), CurrInputFile);
#ifdef ELF2HEX_DEBUG
  llvm::dbgs() &lt;&lt; Name &lt;&lt; &quot;\n&quot;;
#endif
}


static cl::opt&lt;bool&gt;
LittleEndian(&quot;le&quot;, 
cl::desc(&quot;Little endian format&quot;));

#ifdef ELF2HEX_DEBUG
// Modified from PrintSectionHeaders()
uint64_t GetSectionHeaderStartAddress(const ObjectFile *Obj, 
  StringRef sectionName) {
//  outs() &lt;&lt; &quot;Sections:\n&quot;
//            &quot;Idx Name          Size      Address          Type\n&quot;;
  std::error_code ec;
  unsigned i = 0;
  for (const SectionRef &amp;Section : Obj-&gt;sections()) {
    error(ec);
    StringRef Name;
    error(getName(Section, Name));
    uint64_t Address;
    Address = Section.getAddress();
    uint64_t Size;
    Size = Section.getSize();
    bool Text;
    Text = Section.isText();
    if (Name == sectionName)
      return Address;
    else
      return 0;
    ++i;
  }
  return 0;
}
#endif

// Reference from llvm::printSymbolTable of llvm-objdump.cpp
uint64_t GetSymbolAddress(const ObjectFile *o, StringRef SymbolName) {
  for (const SymbolRef &amp;Symbol : o-&gt;symbols()) {
    Expected&lt;uint64_t&gt; AddressOrError = Symbol.getAddress();
    if (!AddressOrError)
      reportError(o-&gt;getFileName(), SymbolName);
    uint64_t Address = *AddressOrError;
    Expected&lt;SymbolRef::Type&gt; TypeOrError = Symbol.getType();
    if (!TypeOrError)
      reportError(o-&gt;getFileName(), SymbolName);
    SymbolRef::Type Type = *TypeOrError;
    section_iterator Section = unwrapOrError(Symbol.getSection(), CurrInputFile);
    StringRef Name;
    if (Type == SymbolRef::ST_Debug &amp;&amp; Section != o-&gt;section_end()) {
      if (Expected&lt;StringRef&gt; NameOrErr = Section-&gt;getName())
        Name = *NameOrErr;
      else
        consumeError(NameOrErr.takeError());
    } else {
      Name = unwrapOrError(Symbol.getName(), o-&gt;getFileName());
    }
    if (Name == SymbolName)
      return Address;
  }
  return 0;
}

uint64_t SectionOffset(const ObjectFile *o, StringRef secName) {
  for (const SectionRef &amp;Section : o-&gt;sections()) {
    StringRef Name;
    uint64_t BaseAddr;
    Name = unwrapOrError(Section.getName(), o-&gt;getFileName());
    unwrapOrError(Section.getContents(), o-&gt;getFileName());
    BaseAddr = Section.getAddress();

    if (Name == secName)
      return BaseAddr;
  }
  return 0;
}

using namespace llvm::elf2hex;

Reader reader;

VerilogHex::VerilogHex(std::unique_ptr&lt;MCInstPrinter&gt;&amp; instructionPointer, 
  std::unique_ptr&lt;const MCSubtargetInfo&gt;&amp; subTargetInfo, const ObjectFile *Obj) :
  IP(instructionPointer), STI(subTargetInfo) {
  lastDumpAddr = 0;
#ifdef ELF2HEX_DEBUG
  //uint64_t startAddr = GetSectionHeaderStartAddress(Obj, &quot;_start&quot;);
  //errs() &lt;&lt; format(&quot;_start address:%08&quot; PRIx64 &quot;\n&quot;, startAddr);
#endif
  uint64_t isrAddr = GetSymbolAddress(Obj, &quot;ISR&quot;);
  errs() &lt;&lt; format(&quot;ISR address:%08&quot; PRIx64 &quot;\n&quot;, isrAddr);

  //uint64_t pltOffset = SectionOffset(Obj, &quot;.plt&quot;);
  uint64_t textOffset = SectionOffset(Obj, &quot;.text&quot;);
  PrintBootSection(textOffset, isrAddr, LittleEndian);
  lastDumpAddr = BOOT_SIZE;
  Fill0s(lastDumpAddr, 0x100);
  lastDumpAddr = 0x100;
}

void VerilogHex::PrintBootSection(uint64_t textOffset, uint64_t isrAddr, 
                                  bool isLittleEndian) {
  uint64_t offset = textOffset - 4;

  // isr instruction at 0x8 and PC counter point to next instruction
  uint64_t isrOffset = isrAddr - 8 - 4;
  if (isLittleEndian) {
    outs() &lt;&lt; &quot;/*       0:*/	&quot;;
    outs() &lt;&lt; format(&quot;%02&quot; PRIx64 &quot; &quot;, (offset &amp; 0xff));
    outs() &lt;&lt; format(&quot;%02&quot; PRIx64 &quot; &quot;, (offset &amp; 0xff00) &gt;&gt; 8);
    outs() &lt;&lt; format(&quot;%02&quot; PRIx64 &quot;&quot;, (offset &amp; 0xff0000) &gt;&gt; 16);
    outs() &lt;&lt; &quot; 36&quot;;
    outs() &lt;&lt; &quot;                                  /*	jmp	0x&quot;;
    outs() &lt;&lt; format(&quot;%02&quot; PRIx64 &quot;%02&quot; PRIx64 &quot;%02&quot; PRIx64 &quot; */\n&quot;,
      (offset &amp; 0xff0000) &gt;&gt; 16, (offset &amp; 0xff00) &gt;&gt; 8, (offset &amp; 0xff));
    outs() &lt;&lt;
      &quot;/*       4:*/	04 00 00 36                                  /*	jmp	4 */\n&quot;;
    offset -= 8;
    outs() &lt;&lt; &quot;/*       8:*/	&quot;;
    outs() &lt;&lt; format(&quot;%02&quot; PRIx64 &quot; &quot;, (isrOffset &amp; 0xff));
    outs() &lt;&lt; format(&quot;%02&quot; PRIx64 &quot; &quot;, (isrOffset &amp; 0xff00) &gt;&gt; 8);
    outs() &lt;&lt; format(&quot;%02&quot; PRIx64 &quot;&quot;, (isrOffset &amp; 0xff0000) &gt;&gt; 16);
    outs() &lt;&lt; &quot; 36&quot;;
    outs() &lt;&lt; &quot;                                  /*	jmp	0x&quot;;
    outs() &lt;&lt; format(&quot;%02&quot; PRIx64 &quot;%02&quot; PRIx64 &quot;%02&quot; PRIx64 &quot; */\n&quot;,
      (isrOffset &amp; 0xff0000) &gt;&gt; 16, (isrOffset &amp; 0xff00) &gt;&gt; 8, (isrOffset &amp; 0xff));
    outs() &lt;&lt;
      &quot;/*       c:*/	fc ff ff 36                                  /*	jmp	-4 */\n&quot;;
  }
  else {
    outs() &lt;&lt; &quot;/*       0:*/	36 &quot;;
    outs() &lt;&lt; format(&quot;%02&quot; PRIx64 &quot; &quot;, (offset &amp; 0xff0000) &gt;&gt; 16);
    outs() &lt;&lt; format(&quot;%02&quot; PRIx64 &quot; &quot;, (offset &amp; 0xff00) &gt;&gt; 8);
    outs() &lt;&lt; format(&quot;%02&quot; PRIx64 &quot;&quot;, (offset &amp; 0xff));
    outs() &lt;&lt; &quot;                                  /*	jmp	0x&quot;;
    outs() &lt;&lt; format(&quot;%02&quot; PRIx64 &quot;%02&quot; PRIx64 &quot;%02&quot; PRIx64 &quot; */\n&quot;,
      (offset &amp; 0xff0000) &gt;&gt; 16, (offset &amp; 0xff00) &gt;&gt; 8, (offset &amp; 0xff));
    outs() &lt;&lt;
      &quot;/*       4:*/	36 00 00 04                                  /*	jmp	4 */\n&quot;;
    offset -= 8;
    outs() &lt;&lt; &quot;/*       8:*/	36 &quot;;
    outs() &lt;&lt; format(&quot;%02&quot; PRIx64 &quot; &quot;, (isrOffset &amp; 0xff0000) &gt;&gt; 16);
    outs() &lt;&lt; format(&quot;%02&quot; PRIx64 &quot; &quot;, (isrOffset &amp; 0xff00) &gt;&gt; 8);
    outs() &lt;&lt; format(&quot;%02&quot; PRIx64 &quot;&quot;, (isrOffset &amp; 0xff));
    outs() &lt;&lt; &quot;                                  /*	jmp	0x&quot;;
    outs() &lt;&lt; format(&quot;%02&quot; PRIx64 &quot;%02&quot; PRIx64 &quot;%02&quot; PRIx64 &quot; */\n&quot;,
      (isrOffset &amp; 0xff0000) &gt;&gt; 16, (isrOffset &amp; 0xff00) &gt;&gt; 8, (isrOffset &amp; 0xff));
    outs() &lt;&lt;
      &quot;/*       c:*/	36 ff ff fc                                  /*	jmp	-4 */\n&quot;;
  }
}

// Fill /*address*/ 00 00 00 00 [startAddr..endAddr] from startAddr to endAddr. 
// Include startAddr and endAddr.
void VerilogHex::Fill0s(uint64_t startAddr, uint64_t endAddr) {
  std::size_t addr;

  assert((startAddr &lt;= endAddr) &amp;&amp; &quot;startAddr must &lt;= BaseAddr&quot;);
  // Fill /*address*/ 00 00 00 00 for 4 bytes alignment (1 Cpu0 word size)
  for (addr = startAddr; addr &lt; endAddr; addr += 4) {
    outs() &lt;&lt; format(&quot;/*%8&quot; PRIx64 &quot; */&quot;, addr);
    outs() &lt;&lt; format(&quot;%02&quot; PRIx64 &quot; &quot;, 0) &lt;&lt; format(&quot;%02&quot; PRIx64 &quot; &quot;, 0) \
    &lt;&lt; format(&quot;%02&quot; PRIx64 &quot; &quot;, 0) &lt;&lt; format(&quot;%02&quot; PRIx64 &quot; &quot;, 0) &lt;&lt; &#39;\n&#39;;
  }

  return;
}

void VerilogHex::ProcessDisAsmInstruction(MCInst inst, uint64_t Size, 
                                ArrayRef&lt;uint8_t&gt; Bytes, const ObjectFile *Obj) {
  SectionRef Section = reader.CurrentSection();
  StringRef Name;
  StringRef Contents;
  Name = unwrapOrError(Section.getName(), Obj-&gt;getFileName());
  unwrapOrError(Section.getContents(), Obj-&gt;getFileName());
  uint64_t SectionAddr = Section.getAddress();
  uint64_t Index = reader.CurrentIndex();
#ifdef ELF2HEX_DEBUG
  errs() &lt;&lt; format(&quot;SectionAddr + Index = %8&quot; PRIx64 &quot;\n&quot;, SectionAddr + Index);
  errs() &lt;&lt; format(&quot;lastDumpAddr %8&quot; PRIx64 &quot;\n&quot;, lastDumpAddr);
#endif
  if (lastDumpAddr &lt; SectionAddr) {
    Fill0s(lastDumpAddr, SectionAddr - 1);
    lastDumpAddr = SectionAddr;
  }

  // print section name when meeting it first time
  if (sectionName != Name) {
    StringRef SegmentName = &quot;&quot;;
    if (const MachOObjectFile *MachO =
        dyn_cast&lt;const MachOObjectFile&gt;(Obj)) {
      DataRefImpl DR = Section.getRawDataRefImpl();
      SegmentName = MachO-&gt;getSectionFinalSegmentName(DR);
    }
    outs() &lt;&lt; &quot;/*&quot; &lt;&lt; &quot;Disassembly of section &quot;;
    if (!SegmentName.empty())
      outs() &lt;&lt; SegmentName &lt;&lt; &quot;,&quot;;
    outs() &lt;&lt; Name &lt;&lt; &#39;:&#39; &lt;&lt; &quot;*/&quot;;
    sectionName = Name;
  }

  if (si != reader.CurrentSi()) {
    // print function name in section .text just before the first instruction 
    // is printed
    outs() &lt;&lt; &#39;\n&#39; &lt;&lt; &quot;/*&quot; &lt;&lt; reader.CurrentSymbol() &lt;&lt; &quot;:*/\n&quot;;
    si = reader.CurrentSi();
  }

  // print instruction address
  outs() &lt;&lt; format(&quot;/*%8&quot; PRIx64 &quot;:*/&quot;, SectionAddr + Index);
 
  // print instruction in hex format
  outs() &lt;&lt; &quot;\t&quot;;
  dumpBytes(Bytes.slice(Index, Size), outs());

  outs() &lt;&lt; &quot;/*&quot;;
  // print disassembly instruction to outs()
  IP-&gt;printInst(&amp;inst, 0, &quot;&quot;, *STI, outs());
  outs() &lt;&lt; &quot;*/&quot;;
  outs() &lt;&lt; &quot;\n&quot;;

  // In section .plt or .text, the Contents.size() maybe &lt; (SectionAddr + Index + 4)
  if (Contents.size() &lt; (SectionAddr + Index + 4))
    lastDumpAddr = SectionAddr + Index + 4;
  else
    lastDumpAddr = SectionAddr + Contents.size();
}

void VerilogHex::ProcessDataSection(SectionRef Section) {
  std::string Error;
  StringRef Name;
  StringRef Contents;
  uint64_t BaseAddr;
  uint64_t size;
  getName(Section, Name);
  unwrapOrError(Section.getContents(), CurrInputFile);
  BaseAddr = Section.getAddress();

#ifdef ELF2HEX_DEBUG
  errs() &lt;&lt; format(&quot;BaseAddr = %8&quot; PRIx64 &quot;\n&quot;, BaseAddr);
  errs() &lt;&lt; format(&quot;lastDumpAddr %8&quot; PRIx64 &quot;\n&quot;, lastDumpAddr);
#endif
  if (lastDumpAddr &lt; BaseAddr) {
    Fill0s(lastDumpAddr, BaseAddr - 1);
    lastDumpAddr = BaseAddr;
  }
  if ((Name == &quot;.bss&quot; || Name == &quot;.sbss&quot;) &amp;&amp; Contents.size() &gt; 0) {
    size = (Contents.size() + 3)/4*4;
    Fill0s(BaseAddr, BaseAddr + size - 1);
    lastDumpAddr = BaseAddr + size;
    return;
  }
  else {
    PrintDataSection(Section);
  }
}

void VerilogHex::PrintDataSection(SectionRef Section) {
  std::string Error;
  StringRef Name;
  uint64_t BaseAddr;
  uint64_t size;
  getName(Section, Name);
  StringRef Contents = unwrapOrError(Section.getContents(), CurrInputFile);
  BaseAddr = Section.getAddress();

  if (Contents.size() &lt;= 0) {
    return;
  }
  size = (Contents.size()+3)/4*4;

  outs() &lt;&lt; &quot;/*Contents of section &quot; &lt;&lt; Name &lt;&lt; &quot;:*/\n&quot;;
  // Dump out the content as hex and printable ascii characters.
  for (std::size_t addr = 0, end = Contents.size(); addr &lt; end; addr += 16) {
    outs() &lt;&lt; format(&quot;/*%8&quot; PRIx64 &quot; */&quot;, BaseAddr + addr);
    // Dump line of hex.
    for (std::size_t i = 0; i &lt; 16; ++i) {
      if (i != 0 &amp;&amp; i % 4 == 0)
        outs() &lt;&lt; &#39; &#39;;
      if (addr + i &lt; end)
        outs() &lt;&lt; hexdigit((Contents[addr + i] &gt;&gt; 4) &amp; 0xF, true)
               &lt;&lt; hexdigit(Contents[addr + i] &amp; 0xF, true) &lt;&lt; &quot; &quot;;
    }
    // Print ascii.
    outs() &lt;&lt; &quot;/*&quot; &lt;&lt; &quot;  &quot;;
    for (std::size_t i = 0; i &lt; 16 &amp;&amp; addr + i &lt; end; ++i) {
      if (std::isprint(static_cast&lt;unsigned char&gt;(Contents[addr + i]) &amp; 0xFF))
        outs() &lt;&lt; Contents[addr + i];
      else
        outs() &lt;&lt; &quot;.&quot;;
    }
    outs() &lt;&lt; &quot;*/&quot; &lt;&lt; &quot;\n&quot;;
  }
  for (std::size_t i = Contents.size(); i &lt; size; i++) {
    outs() &lt;&lt; &quot;00 &quot;;
  }
  outs() &lt;&lt; &quot;\n&quot;;
#ifdef ELF2HEX_DEBUG
  errs() &lt;&lt; &quot;Name &quot; &lt;&lt; Name &lt;&lt; &quot;  BaseAddr &quot;;
  errs() &lt;&lt; format(&quot;%8&quot; PRIx64 &quot; Contents.size() &quot;, BaseAddr);
  errs() &lt;&lt; format(&quot;%8&quot; PRIx64 &quot; size &quot;, Contents.size());
  errs() &lt;&lt; format(&quot;%8&quot; PRIx64 &quot; \n&quot;, size);
#endif
  // save the end address of this section to lastDumpAddr
  lastDumpAddr = BaseAddr + size;
}

StringRef Reader::CurrentSymbol() {
  return Symbols[si].second;
}

SectionRef Reader::CurrentSection() {
  return _section;
}

unsigned Reader::CurrentSi() {
  return si;
}

uint64_t Reader::CurrentIndex() {
  return Index;
}

// Porting from DisassembleObject() of llvm-objump.cpp
void Reader::DisassembleObject(const ObjectFile *Obj
/*, bool InlineRelocs*/  , std::unique_ptr&lt;MCDisassembler&gt;&amp; DisAsm, 
  std::unique_ptr&lt;MCInstPrinter&gt;&amp; IP,
  std::unique_ptr&lt;const MCSubtargetInfo&gt;&amp; STI) {
  VerilogHex hexOut(IP, STI, Obj);
  std::error_code ec;
  for (const SectionRef &amp;Section : Obj-&gt;sections()) {
    _section = Section;
    uint64_t BaseAddr;
    unwrapOrError(Section.getContents(), Obj-&gt;getFileName());
    BaseAddr = Section.getAddress();
    uint64_t SectSize = Section.getSize();
    if (!SectSize)
      continue;

    if (BaseAddr &lt; 0x100)
      continue;
 
  #ifdef ELF2HEX_DEBUG
    StringRef SectionName = unwrapOrError(Section.getName(), Obj-&gt;getFileName());
    errs() &lt;&lt; &quot;SectionName &quot; &lt;&lt; SectionName &lt;&lt; format(&quot;  BaseAddr %8&quot; PRIx64 &quot;\n&quot;, BaseAddr);
  #endif
 
    bool text;
    text = Section.isText();
    if (!text) {
      hexOut.ProcessDataSection(Section);
      continue;
    }
    // It&#39;s .text section
    uint64_t SectionAddr;
    SectionAddr = Section.getAddress();
 
    // Make a list of all the symbols in this section.
    for (const SymbolRef &amp;Symbol : Obj-&gt;symbols()) {
      if (Section.containsSymbol(Symbol)) {
        Expected&lt;uint64_t&gt; AddressOrErr = Symbol.getAddress();
        error(errorToErrorCode(AddressOrErr.takeError()));
        uint64_t Address = *AddressOrErr;
        Address -= SectionAddr;
        if (Address &gt;= SectSize)
          continue;

        Expected&lt;StringRef&gt; Name = Symbol.getName();
        error(errorToErrorCode(Name.takeError()));
        Symbols.push_back(std::make_pair(Address, *Name));
      }
    }

    // Sort the symbols by address, just in case they didn&#39;t come in that way.
    array_pod_sort(Symbols.begin(), Symbols.end());
  #ifdef ELF2HEX_DEBUG
    for (unsigned si = 0, se = Symbols.size(); si != se; ++si) {
        errs() &lt;&lt; &#39;\n&#39; &lt;&lt; &quot;/*&quot; &lt;&lt; Symbols[si].first &lt;&lt; &quot;  &quot; &lt;&lt; Symbols[si].second &lt;&lt; &quot;:*/\n&quot;;
    }
  #endif

    // Make a list of all the relocations for this section.
    std::vector&lt;RelocationRef&gt; Rels;

    // Sort relocations by address.
    std::sort(Rels.begin(), Rels.end(), isRelocAddressLess);

    StringRef name;
    getName(Section, name);

    // If the section has no symbols just insert a dummy one and disassemble
    // the whole section.
    if (Symbols.empty())
      Symbols.push_back(std::make_pair(0, name));

    SmallString&lt;40&gt; Comments;
    raw_svector_ostream CommentStream(Comments);

    ArrayRef&lt;uint8_t&gt; Bytes = arrayRefFromStringRef(
        unwrapOrError(Section.getContents(), Obj-&gt;getFileName()));
#if 0
    Section.getContents();
    ArrayRef&lt;uint8_t&gt; Bytes(reinterpret_cast&lt;const uint8_t *&gt;(BytesStr.data()),
                            BytesStr.size());
#endif
    uint64_t Size;
    SectSize = Section.getSize();

    // Disassemble symbol by symbol.
    unsigned se;
    for (si = 0, se = Symbols.size(); si != se; ++si) {
      uint64_t Start = Symbols[si].first;
      uint64_t End;
      // The end is either the size of the section or the beginning of the next
      // symbol.
      if (si == se - 1)
        End = SectSize;
      // Make sure this symbol takes up space.
      else if (Symbols[si + 1].first != Start)
        End = Symbols[si + 1].first - 1;
      else {
        continue;
      }

      for (Index = Start; Index &lt; End; Index += Size) {
        MCInst Inst;
        if (DisAsm-&gt;getInstruction(Inst, Size, Bytes.slice(Index),
                                   SectionAddr + Index, CommentStream)) {
          hexOut.ProcessDisAsmInstruction(Inst, Size, Bytes, Obj);
        } else {
          errs() &lt;&lt; ToolName &lt;&lt; &quot;: warning: invalid instruction encoding\n&quot;;
          if (Size == 0)
            Size = 1; // skip illegible bytes
        }
      } // for
    } // for
  }
}

// Porting from disassembleObject() of llvm-objump.cpp
static void Elf2Hex(const ObjectFile *Obj) {

  const Target *TheTarget = getTarget(Obj);

  // Package up features to be passed to target/subtarget
  SubtargetFeatures Features = Obj-&gt;getFeatures();

  std::unique_ptr&lt;const MCRegisterInfo&gt; MRI(TheTarget-&gt;createMCRegInfo(TripleName));
  if (!MRI)
    report_fatal_error(&quot;error: no register info for target &quot; + TripleName);

  // Set up disassembler.
  MCTargetOptions MCOptions;
  std::unique_ptr&lt;const MCAsmInfo&gt; AsmInfo(
    TheTarget-&gt;createMCAsmInfo(*MRI, TripleName, MCOptions));
  if (!AsmInfo)
    report_fatal_error(&quot;error: no assembly info for target &quot; + TripleName);

  std::unique_ptr&lt;const MCSubtargetInfo&gt; STI(
    TheTarget-&gt;createMCSubtargetInfo(TripleName, &quot;&quot;, Features.getString()));
  if (!STI)
    report_fatal_error(&quot;error: no subtarget info for target &quot; + TripleName);

  std::unique_ptr&lt;const MCInstrInfo&gt; MII(TheTarget-&gt;createMCInstrInfo());
  if (!MII)
    report_fatal_error(&quot;error: no instruction info for target &quot; + TripleName);

  MCObjectFileInfo MOFI;
  MCContext Ctx(AsmInfo.get(), MRI.get(), &amp;MOFI);
  // FIXME: for now initialize MCObjectFileInfo with default values
  MOFI.InitMCObjectFileInfo(Triple(TripleName), false, Ctx);

  std::unique_ptr&lt;MCDisassembler&gt; DisAsm(
    TheTarget-&gt;createMCDisassembler(*STI, Ctx));
  if (!DisAsm)
    report_fatal_error(&quot;error: no disassembler for target &quot; + TripleName);

  std::unique_ptr&lt;const MCInstrAnalysis&gt; MIA(
      TheTarget-&gt;createMCInstrAnalysis(MII.get()));

  int AsmPrinterVariant = AsmInfo-&gt;getAssemblerDialect();
  std::unique_ptr&lt;MCInstPrinter&gt; IP(TheTarget-&gt;createMCInstPrinter(
      Triple(TripleName), AsmPrinterVariant, *AsmInfo, *MII, *MRI));
  if (!IP)
    report_fatal_error(&quot;error: no instruction printer for target &quot; +
                       TripleName);

  std::error_code EC;
  reader.DisassembleObject(Obj, DisAsm, IP, STI);
}

static void DumpObject(const ObjectFile *o) {
  outs() &lt;&lt; &quot;/*&quot;;
  outs() &lt;&lt; o-&gt;getFileName()
         &lt;&lt; &quot;:\tfile format &quot; &lt;&lt; o-&gt;getFileFormatName() &lt;&lt; &quot;*/&quot;;
  outs() &lt;&lt; &quot;\n\n&quot;;

  Elf2Hex(o);
}

/// @brief Open file and figure out how to dump it.
static void DumpInput(StringRef file) {
  CurrInputFile = file;
  // Attempt to open the binary.
  Expected&lt;OwningBinary&lt;Binary&gt;&gt; BinaryOrErr = createBinary(file);
  if (!BinaryOrErr)
    reportError(file, &quot;no this file&quot;);

  Binary &amp;Binary = *BinaryOrErr.get().getBinary();

  if (ObjectFile *o = dyn_cast&lt;ObjectFile&gt;(&amp;Binary))
    DumpObject(o);
  else
    reportError(file, &quot;invalid_file_type&quot;);
}

int main(int argc, char **argv) {
  // Print a stack trace if we signal out.
  //sys::PrintStackTraceOnErrorSignal(argv[0]);
  //PrettyStackTraceProgram X(argc, argv);
  //llvm_shutdown_obj Y;  // Call llvm_shutdown() on exit.

  using namespace llvm;
  InitLLVM X(argc, argv);

  // Initialize targets and assembly printers/parsers.
  llvm::InitializeAllTargetInfos();
  llvm::InitializeAllTargetMCs();
  llvm::InitializeAllDisassemblers();

  // Register the target printer for --version.
  cl::AddExtraVersionPrinter(TargetRegistry::printRegisteredTargetsForVersion);

  cl::ParseCommandLineOptions(argc, argv, &quot;llvm object file dumper\n&quot;);
//  TripleName = Triple::normalize(TripleName);

  ToolName = argv[0];

  // Defaults to a.out if no filenames specified.
  if (InputFilenames.size() == 0)
    InputFilenames.push_back(&quot;a.out&quot;);

  std::for_each(InputFilenames.begin(), InputFilenames.end(),
                DumpInput);

  return EXIT_SUCCESS;
}

</pre></div>
</div>
<p>In order to support command, <strong>llvm-objdump -d</strong> and <strong>llvm-objdump -t</strong>, for
Cpu0, the code add to llvm-objdump.cpp as follows,</p>
<p class="rubric">exlbt/llvm-objdump/llvm-objdump.cpp</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">case</span><span class="w"> </span><span class="n">ELF</span><span class="o">::</span><span class="n">EM_CPU0</span><span class="o">:</span><span class="w"> </span><span class="c1">//Cpu0</span>
</pre></div>
</div>
</section>
<section id="create-cpu0-backend-under-lld">
<h2><a class="toc-backref" href="#id18">Create Cpu0 backend under LLD</a><a class="headerlink" href="#create-cpu0-backend-under-lld" title="Permalink to this headline">¶</a></h2>
<section id="lld-introduction">
<h3><a class="toc-backref" href="#id19">LLD introduction</a><a class="headerlink" href="#lld-introduction" title="Permalink to this headline">¶</a></h3>
<p>In general, linker do the Relocation Records Resolve as Chapter ELF support
depicted, and optimization for those cannot finish in compiler stage. One of
the optimization opportunities in linker is Dead Code Stripping which is
explained as follows,</p>
<p class="rubric">Dead code stripping - example (modified from llvm lto document web)</p>
<p class="rubric">a.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">extern</span> <span class="nb">int</span> <span class="n">foo1</span><span class="p">(</span><span class="n">void</span><span class="p">);</span>
<span class="n">extern</span> <span class="n">void</span> <span class="n">foo2</span><span class="p">(</span><span class="n">void</span><span class="p">);</span>
<span class="n">extern</span> <span class="nb">int</span> <span class="n">foo4</span><span class="p">(</span><span class="n">void</span><span class="p">);</span>

</pre></div>
</div>
<p class="rubric">a.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#include &quot;a.h&quot;</span>

<span class="n">static</span> <span class="n">signed</span> <span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="n">void</span> <span class="n">foo2</span><span class="p">(</span><span class="n">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">static</span> <span class="nb">int</span> <span class="n">foo3</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="mi">10</span><span class="o">+</span><span class="n">foo4</span><span class="p">());</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">foo1</span><span class="p">(</span><span class="n">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="nb">int</span> <span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">foo3</span><span class="p">();</span>

  <span class="n">data</span> <span class="o">=</span> <span class="n">data</span> <span class="o">+</span> <span class="mi">42</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>

</pre></div>
</div>
<p class="rubric">ch13_1.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#include &quot;a.h&quot;</span>

<span class="n">void</span> <span class="n">ISR</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">asm</span><span class="p">(</span><span class="s2">&quot;ISR:&quot;</span><span class="p">);</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">foo4</span><span class="p">(</span><span class="n">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mi">5</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">foo1</span><span class="p">();</span>
<span class="p">}</span>

</pre></div>
</div>
<p>Above code can be reduced to <a class="reference internal" href="#lld-deadcodestripping"><span class="std std-numref">Fig. 4</span></a> to perform
mark and swip in graph for Dead Code Stripping.</p>
<figure class="align-center" id="id16">
<span id="lld-deadcodestripping"></span><a class="reference internal image-reference" href="_images/deadcodestripping.png"><img alt="_images/deadcodestripping.png" src="_images/deadcodestripping.png" style="width: 144.4px; height: 270.8px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 4 </span><span class="caption-text">Atom classified (from lld web)</span><a class="headerlink" href="#id16" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>As above example, the foo2() is an isolated node without any reference. It’s
dead code and can be removed in linker optimization. We test this example by
Makefile.ch13_1 and find foo2() cannot be removed.
There are two possibilities for this situation.
One is we do not trigger lld dead code stripping
optimization in command (the default is not do it). The other is lld hasn’t
implemented it yet at this point. It’s reasonable since the
lld is in its early stages of development. We didn’t dig it more, since the
Cpu0 backend tutorial just need a linker to finish Relocation Records Resolve
and see how it runs on PC.</p>
<p>Remind, llvm-linker is the linker works on IR level linker optimization.
Sometime when you got the obj file only (if you have a.o in this case),
the native linker (such as lld) have the opportunity to do Dead Code Stripping
while the IR linker hasn’t.</p>
</section>
<section id="static-linker">
<h3><a class="toc-backref" href="#id20">Static linker</a><a class="headerlink" href="#static-linker" title="Permalink to this headline">¶</a></h3>
<p>Let’s run the static linker first and explain it next.</p>
<p>File printf-stdarg.c <a class="footnote-reference brackets" href="#printf-stdarg" id="id3">7</a> come from internet download which is
GPL2 license. GPL2 is more restricted than LLVM license.</p>
<p class="rubric">exlbt/input/printf-stdarg-1.c</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>/*
  Copyright 2001, 2002 Georges Menie (www.menie.org)
  stdarg version contributed by Christian Ettinger

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

/*
  putchar is the only external dependency for this file,
  if you have a working putchar, leave it commented out.
  If not, uncomment the define below and
  replace outbyte(c) by your own function call.

#define putchar(c) outbyte(c)
*/

// gcc printf-stdarg-1.c
// ./a.out

#include &lt;stdio.h&gt;

#define TEST_PRINTF

#ifdef TEST_PRINTF
int main(void)
{
  char *ptr = &quot;Hello world!&quot;;
  char *np = 0;
  int i = 5;
  unsigned int bs = sizeof(int)*8;
  int mi;
  char buf[80];

  mi = (1 &lt;&lt; (bs-1)) + 1;
  printf(&quot;%s\n&quot;, ptr);
  printf(&quot;printf test\n&quot;);
  printf(&quot;%s is null pointer\n&quot;, np);
  printf(&quot;%d = 5\n&quot;, i);
  printf(&quot;%d = - max int\n&quot;, mi);
  printf(&quot;char %c = &#39;a&#39;\n&quot;, &#39;a&#39;);
  printf(&quot;hex %x = ff\n&quot;, 0xff);
  printf(&quot;hex %02x = 00\n&quot;, 0);
  printf(&quot;signed %d = unsigned %u = hex %x\n&quot;, -3, -3, -3);
  printf(&quot;%d %s(s)%&quot;, 0, &quot;message&quot;);
  printf(&quot;\n&quot;);
  printf(&quot;%d %s(s) with %%\n&quot;, 0, &quot;message&quot;);
  sprintf(buf, &quot;justif: \&quot;%-10s\&quot;\n&quot;, &quot;left&quot;); printf(&quot;%s&quot;, buf);
  sprintf(buf, &quot;justif: \&quot;%10s\&quot;\n&quot;, &quot;right&quot;); printf(&quot;%s&quot;, buf);
  sprintf(buf, &quot; 3: %04d zero padded\n&quot;, 3); printf(&quot;%s&quot;, buf);
  sprintf(buf, &quot; 3: %-4d left justif.\n&quot;, 3); printf(&quot;%s&quot;, buf);
  sprintf(buf, &quot; 3: %4d right justif.\n&quot;, 3); printf(&quot;%s&quot;, buf);
  sprintf(buf, &quot;-3: %04d zero padded\n&quot;, -3); printf(&quot;%s&quot;, buf);
  sprintf(buf, &quot;-3: %-4d left justif.\n&quot;, -3); printf(&quot;%s&quot;, buf);
  sprintf(buf, &quot;-3: %4d right justif.\n&quot;, -3); printf(&quot;%s&quot;, buf);

  return 0;
}

/*
 * if you compile this file with
 *   gcc -Wall $(YOUR_C_OPTIONS) -DTEST_PRINTF -c printf.c
 * you will get a normal warning:
 *   printf.c:214: warning: spurious trailing `%&#39; in format
 * this line is testing an invalid % at the end of the format string.
 *
 * this should display (on 32bit int machine) :
 *
 * Hello world!
 * printf test
 * (null) is null pointer
 * 5 = 5
 * -2147483647 = - max int
 * char a = &#39;a&#39;
 * hex ff = ff
 * hex 00 = 00
 * signed -3 = unsigned 4294967293 = hex fffffffd
 * 0 message(s)
 * 0 message(s) with %
 * justif: &quot;left      &quot;
 * justif: &quot;     right&quot;
 *  3: 0003 zero padded
 *  3: 3    left justif.
 *  3:    3 right justif.
 * -3: -003 zero padded
 * -3: -3   left justif.
 * -3:   -3 right justif.
 */

#endif
</pre></div>
</div>
<p class="rubric">exlbt/input/printf-stdarg-def.c</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
<span class="c1">#include &quot;print.h&quot;</span>

<span class="o">//</span> <span class="n">Definition</span> <span class="n">putchar</span><span class="p">(</span><span class="nb">int</span> <span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">printf</span><span class="o">-</span><span class="n">stdarg</span><span class="o">.</span><span class="n">c</span>
<span class="o">//</span> <span class="n">For</span> <span class="n">memory</span> <span class="n">IO</span>
<span class="nb">int</span> <span class="n">putchar</span><span class="p">(</span><span class="nb">int</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">char</span><span class="o">*</span><span class="p">)</span><span class="n">IOADDR</span><span class="p">;</span>
  <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">exlbt/input/printf-stdarg.c</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>/*
  Copyright 2001, 2002 Georges Menie (www.menie.org)
  stdarg version contributed by Christian Ettinger

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

/*
  putchar is the only external dependency for this file,
  if you have a working putchar, leave it commented out.
  If not, uncomment the define below and
  replace outbyte(c) by your own function call.

#define putchar(c) outbyte(c)
*/

#include &lt;stdarg.h&gt;

static void printchar(char **str, int c)
{
  extern int putchar(int c);
  
  if (str) {
    **str = c;
    ++(*str);
  }
  else (void)putchar(c);
}

#define PAD_RIGHT 1
#define PAD_ZERO 2

static int prints(char **out, const char *string, int width, int pad)
{
  int pc = 0, padchar = &#39; &#39;;

  if (width &gt; 0) {
    int len = 0;
    const char *ptr;
    for (ptr = string; *ptr; ++ptr) ++len;
    if (len &gt;= width) width = 0;
    else width -= len;
    if (pad &amp; PAD_ZERO) padchar = &#39;0&#39;;
  }
  if (!(pad &amp; PAD_RIGHT)) {
    for ( ; width &gt; 0; --width) {
      printchar (out, padchar);
      ++pc;
    }
  }
  for ( ; *string ; ++string) {
    printchar (out, *string);
    ++pc;
  }
  for ( ; width &gt; 0; --width) {
    printchar (out, padchar);
    ++pc;
  }

  return pc;
}

/* the following should be enough for 32 bit int */
#define PRINT_BUF_LEN 12

static int printi(char **out, int i, int b, int sg, int width, int pad, int letbase)
{
  char print_buf[PRINT_BUF_LEN];
  char *s;
  int t, neg = 0, pc = 0;
  unsigned int u = i;

  if (i == 0) {
    print_buf[0] = &#39;0&#39;;
    print_buf[1] = &#39;\0&#39;;
    return prints (out, print_buf, width, pad);
  }

  if (sg &amp;&amp; b == 10 &amp;&amp; i &lt; 0) {
    neg = 1;
    u = -i;
  }

  s = print_buf + PRINT_BUF_LEN-1;
  *s = &#39;\0&#39;;

  while (u) {
    t = u % b;
    if( t &gt;= 10 )
      t += letbase - &#39;0&#39; - 10;
    *--s = t + &#39;0&#39;;
    u /= b;
  }

  if (neg) {
    if( width &amp;&amp; (pad &amp; PAD_ZERO) ) {
      printchar (out, &#39;-&#39;);
      ++pc;
      --width;
    }
    else {
      *--s = &#39;-&#39;;
    }
  }

  return pc + prints (out, s, width, pad);
}

static int print(char **out, const char *format, va_list args )
{
  int width, pad;
  int pc = 0;
  char scr[2];

  for (; *format != 0; ++format) {
    if (*format == &#39;%&#39;) {
      ++format;
      width = pad = 0;
      if (*format == &#39;\0&#39;) break;
      if (*format == &#39;%&#39;) goto out;
      if (*format == &#39;-&#39;) {
        ++format;
        pad = PAD_RIGHT;
      }
      //bool have_ll = (format[0] == &#39;l&#39; &amp;&amp; format[1] == &#39;l&#39;);
      //pc += have_ll * 2;
      while (*format == &#39;0&#39;) {
        ++format;
        pad |= PAD_ZERO;
      }
      for ( ; *format &gt;= &#39;0&#39; &amp;&amp; *format &lt;= &#39;9&#39;; ++format) {
        width *= 10;
        width += *format - &#39;0&#39;;
      }
      if( *format == &#39;s&#39; ) {
        char *s = (char *)va_arg( args, int );
        pc += prints (out, s?s:&quot;(null)&quot;, width, pad);
        continue;
      }
      if( *format == &#39;d&#39; ) {
        pc += printi (out, va_arg( args, int ), 10, 1, width, pad, &#39;a&#39;);
        continue;
      }
      if( *format == &#39;x&#39; ) {
        pc += printi (out, va_arg( args, int ), 16, 0, width, pad, &#39;a&#39;);
        continue;
      }
      if( *format == &#39;X&#39; ) {
        pc += printi (out, va_arg( args, int ), 16, 0, width, pad, &#39;A&#39;);
        continue;
      }
      if( *format == &#39;u&#39; ) {
        pc += printi (out, va_arg( args, int ), 10, 0, width, pad, &#39;a&#39;);
        continue;
      }
      if( *format == &#39;c&#39; ) {
        /* char are converted to int then pushed on the stack */
        scr[0] = (char)va_arg( args, int );
        scr[1] = &#39;\0&#39;;
        pc += prints (out, scr, width, pad);
        continue;
      }
    }
    else {
    out:
      printchar (out, *format);
      ++pc;
    }
  }
  if (out) **out = &#39;\0&#39;;
  va_end( args );
  return pc;
}

int printf(const char *format, ...)
{
        va_list args;
        
        va_start( args, format );
        return print( 0, format, args );
}

int sprintf(char *out, const char *format, ...)
{
        va_list args;
        
        va_start( args, format );
        return print( &amp;out, format, args );
}

#ifdef TEST_PRINTF
int main(void)
{
  char ptr[] = &quot;Hello world!&quot;;
  char *np = 0;
  int i = 5;
  unsigned int bs = sizeof(int)*8;
  int mi;
  char buf[80];

  mi = (1 &lt;&lt; (bs-1)) + 1;
  printf(&quot;%s\n&quot;, ptr);
  printf(&quot;printf test\n&quot;);
  printf(&quot;%s is null pointer\n&quot;, np);
  printf(&quot;%d = 5\n&quot;, i);
  printf(&quot;%d = - max int\n&quot;, mi);
  printf(&quot;char %c = &#39;a&#39;\n&quot;, &#39;a&#39;);
  printf(&quot;hex %x = ff\n&quot;, 0xff);
  printf(&quot;hex %02x = 00\n&quot;, 0);
  printf(&quot;signed %d = unsigned %u = hex %x\n&quot;, -3, -3, -3);
  printf(&quot;%d %s(s)&quot;, 0, &quot;message&quot;);
  printf(&quot;\n&quot;);
  printf(&quot;%d %s(s) with %%\n&quot;, 0, &quot;message&quot;);
  sprintf(buf, &quot;justif: \&quot;%-10s\&quot;\n&quot;, &quot;left&quot;); printf(&quot;%s&quot;, buf);
  sprintf(buf, &quot;justif: \&quot;%10s\&quot;\n&quot;, &quot;right&quot;); printf(&quot;%s&quot;, buf);
  sprintf(buf, &quot; 3: %04d zero padded\n&quot;, 3); printf(&quot;%s&quot;, buf);
  sprintf(buf, &quot; 3: %-4d left justif.\n&quot;, 3); printf(&quot;%s&quot;, buf);
  sprintf(buf, &quot; 3: %4d right justif.\n&quot;, 3); printf(&quot;%s&quot;, buf);
  sprintf(buf, &quot;-3: %04d zero padded\n&quot;, -3); printf(&quot;%s&quot;, buf);
  sprintf(buf, &quot;-3: %-4d left justif.\n&quot;, -3); printf(&quot;%s&quot;, buf);
  sprintf(buf, &quot;-3: %4d right justif.\n&quot;, -3); printf(&quot;%s&quot;, buf);

  return 0;
}

/*
 * if you compile this file with
 *   gcc -Wall $(YOUR_C_OPTIONS) -DTEST_PRINTF -c printf.c
 * you will get a normal warning:
 *   printf.c:214: warning: spurious trailing `%&#39; in format
 * this line is testing an invalid % at the end of the format string.
 *
 * this should display (on 32bit int machine) :
 *
 * Hello world!
 * printf test
 * (null) is null pointer
 * 5 = 5
 * -2147483647 = - max int
 * char a = &#39;a&#39;
 * hex ff = ff
 * hex 00 = 00
 * signed -3 = unsigned 4294967293 = hex fffffffd
 * 0 message(s)
 * 0 message(s) with %
 * justif: &quot;left      &quot;
 * justif: &quot;     right&quot;
 *  3: 0003 zero padded
 *  3: 3    left justif.
 *  3:    3 right justif.
 * -3: -003 zero padded
 * -3: -3   left justif.
 * -3:   -3 right justif.
 */

#endif
</pre></div>
</div>
<p class="rubric">exlbt/input/start.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
<span class="c1">#include &quot;start.h&quot;</span>

<span class="n">extern</span> <span class="nb">int</span> <span class="n">main</span><span class="p">();</span>

<span class="o">//</span> <span class="n">Real</span> <span class="n">entry</span> <span class="p">(</span><span class="n">first</span> <span class="n">instruction</span><span class="p">)</span> <span class="ow">is</span> <span class="kn">from</span> <span class="nn">cpu0BootAtomContent</span> <span class="n">of</span> 
<span class="o">//</span> <span class="n">Cpu0RelocationPass</span><span class="o">.</span><span class="n">cpp</span> <span class="n">jump</span> <span class="n">to</span> <span class="n">asm</span><span class="p">(</span><span class="s2">&quot;start:&quot;</span><span class="p">)</span> <span class="n">of</span> <span class="n">start</span><span class="o">.</span><span class="n">cpp</span><span class="o">.</span>
<span class="n">void</span> <span class="n">start</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">asm</span><span class="p">(</span><span class="s2">&quot;start:&quot;</span><span class="p">);</span>
  
  <span class="n">INIT_SP</span>
  <span class="n">initRegs</span><span class="p">();</span>
  <span class="n">main</span><span class="p">();</span>
  <span class="n">asm</span><span class="p">(</span><span class="s2">&quot;addiu $lr, $ZERO, -1&quot;</span><span class="p">);</span>
  <span class="n">asm</span><span class="p">(</span><span class="s2">&quot;ret $lr&quot;</span><span class="p">);</span>
<span class="p">}</span>

</pre></div>
</div>
<p class="rubric">exlbt/input/lib_cpu0.c</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">This</span> <span class="n">file</span> <span class="n">provides</span> <span class="n">function</span> <span class="n">symbols</span> <span class="n">used</span> <span class="k">for</span> <span class="n">c</span><span class="o">++</span> <span class="ow">in</span> <span class="n">lld</span>

<span class="n">void</span> <span class="n">_start</span><span class="p">()</span> <span class="p">{}</span>
<span class="n">void</span> <span class="n">__stack_chk_fail</span><span class="p">()</span> <span class="p">{}</span>
<span class="n">void</span> <span class="n">__stack_chk_guard</span><span class="p">()</span> <span class="p">{}</span>
<span class="n">void</span> <span class="n">_ZdlPv</span><span class="p">()</span> <span class="p">{}</span>
<span class="n">void</span> <span class="n">__dso_handle</span><span class="p">()</span> <span class="p">{}</span>
<span class="n">void</span> <span class="n">_ZNSt8ios_base4InitC1Ev</span><span class="p">()</span> <span class="p">{}</span>
<span class="n">void</span> <span class="n">__cxa_atexit</span><span class="p">()</span> <span class="p">{}</span>
<span class="n">void</span> <span class="n">_ZTVN10__cxxabiv120__si_class_type_infoE</span><span class="p">()</span> <span class="p">{}</span>
<span class="n">void</span> <span class="n">_ZTVN10__cxxabiv117__class_type_infoE</span><span class="p">()</span> <span class="p">{}</span>
<span class="n">void</span> <span class="n">_Znwm</span><span class="p">()</span> <span class="p">{}</span>
<span class="n">void</span> <span class="n">__cxa_pure_virtual</span><span class="p">()</span> <span class="p">{}</span>
<span class="n">void</span> <span class="n">ZNSt8ios_base4InitD1Ev</span><span class="p">()</span> <span class="p">{}</span>
</pre></div>
</div>
<p class="rubric">exlbt/input/Common.mk</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span># Thanks https://makefiletutorial.com

TARGET_EXEC := a.out
BUILD_DIR := ./build-$(CPU)-$(ENDIAN)
TARGET := $(BUILD_DIR)/$(TARGET_EXEC)
SRC_DIR := ./

TOOLDIR := ~/llvm/test/build/bin
CC := $(TOOLDIR)/clang
LLC := $(TOOLDIR)/llc
LD := $(TOOLDIR)/ld.lld
AS := $(TOOLDIR)/clang -static -fintegrated-as -c
RANLIB := $(TOOLDIR)/llvm-ranlib
READELF := $(TOOLDIR)/llvm-readelf

# String substitution for every C/C++ file.
# As an example, hello.cpp turns into ./build/hello.cpp.o
OBJS := $(SRCS:%=$(BUILD_DIR)/%.o)

# String substitution (suffix version without %).
# As an example, ./build/hello.cpp.o turns into ./build/hello.cpp.d
DEPS := $(OBJS:.o=.d)

# Add a prefix to INC_DIRS. So moduleA would become -ImoduleA. GCC understands 
# this -I flag
INC_FLAGS := $(addprefix -I,$(INC_DIRS))

# The -MMD and -MP flags together generate Makefiles for us!
# These files will have .d instead of .o as the output.
# fintegrated-as: for asm code in C/C++
CPPFLAGS := -MMD -MP -target cpu0$(ENDIAN)-unknown-linux-gnu -static \
            -fintegrated-as $(INC_FLAGS) -march=cpu0$(ENDIAN) -mcpu=$(CPU) \
            -mllvm -has-lld=true -DHAS_COMPLEX

LLFLAGS := -mcpu=$(CPU) -relocation-model=static \
  -filetype=obj -has-lld=true

CFLAGS := -target cpu0$(ENDIAN)-unknown-linux-gnu -static -mcpu=$(CPU) \
          -fintegrated-as -Wno-error=implicit-function-declaration
CONFIGURE := CC=&quot;$(CC)&quot; CFLAGS=&quot;$(CFAGS)&quot; AS=&quot;$(AS)&quot; RANLIB=&quot;$(RANLIB)&quot; \
            READELF=&quot;$(READELF)&quot; ../newlib/configure --host=cpu0

#FIND_LIBBUILTINS_DIR := $(shell find . -iname $(LIBBUILTINS_DIR))

$(TARGET): $(OBJS) $(LIBS)
	$(LD) -o $@ $(OBJS) $(LIBS)

$(LIBS):
ifdef LIBBUILTINS_DIR
	$(MAKE) -C $(LIBBUILTINS_DIR) 
endif
ifdef NEWLIB_DIR
	$(MAKE) -C $(NEWLIB_DIR)/$(BUILD_DIR) 
endif

# Build step for C source
$(BUILD_DIR)/%.c.o: %.c
	mkdir -p $(dir $@)
	$(CC) $(CPPFLAGS) $(CFLAGS) -c $&lt; -o $@

# Build step for C++ source
$(BUILD_DIR)/%.cpp.o: %.cpp
	mkdir -p $(dir $@)
	$(CC) $(CPPFLAGS) $(CXXFLAGS) -c $&lt; -o $@

.PHONY: clean
clean: 
	rm -rf $(BUILD_DIR)
ifdef LIBBUILTINS_DIR
	cd $(LIBBUILTINS_DIR) &amp;&amp; $(MAKE) -f Makefile clean
endif
ifdef NEWLIB_DIR
	cd $(NEWLIB_DIR) &amp;&amp; rm -rf build-$(CPU)-$(ENDIAN)/*
endif

# Include the .d makefiles. The - at the f.cnt suppresses the er.crs.cf missing
# Makefiles. Initially, all the .d files will be missing, and we .cn&#39;t want t.cse
# er.crs .c s.cw up.
-include $(DEPS)
</pre></div>
</div>
<p>With the printf() of GPL source code, we can program more test code with it
to verify the previous llvm Cpu0 backend generated program. The following code
is for this purpose.</p>
<p class="rubric">exlbt/input/debug.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>#include &quot;debug.h&quot;

extern &quot;C&quot; int printf(const char *format, ...);

// With read variable form asm, such as sw in this example, the function, 
// ISR_Handler() must entry from beginning. The ISR() enter from &quot;ISR:&quot; will
// has incorrect value for reload instruction in offset. 
// For example, the correct one is: 
//   &quot;addiu $sp, $sp, -12&quot;
//   &quot;mov $fp, $sp&quot;
// ISR:
//   &quot;ld $2, 32($fp)&quot;
// Go to ISR directly, then the $fp is 12+ than original, then it will get
//   &quot;ld $2, 20($fp)&quot; actually.
void ISR_Handler() {
  SAVE_REGISTERS;
  asm(&quot;lui $7, 0xffff&quot;);
  asm(&quot;ori $7, $7, 0xfdff&quot;);
  asm(&quot;and $sw, $sw, $7&quot;); // clear `IE

  volatile int sw;
  __asm__ __volatile__(&quot;addiu %0, $sw, 0&quot;
                       :&quot;=r&quot;(sw)
                       );
  int interrupt = (sw &amp; INT);
  int softint = (sw &amp; SOFTWARE_INT);
  int overflow = (sw &amp; OVERFLOW);
  int int1 = (sw &amp; INT1);
  int int2 = (sw &amp; INT2);
  if (interrupt) {
    if (softint) {
      if (overflow) {
        printf(&quot;Overflow exception\n&quot;);
        CLEAR_OVERFLOW;
      }
      else {
        printf(&quot;Software interrupt\n&quot;);
      }
      CLEAR_SOFTWARE_INT;
    }
    else if (int1) {
      printf(&quot;Harware interrupt 0\n&quot;);
      asm(&quot;lui $7, 0xffff&quot;);
      asm(&quot;ori $7, $7, 0x7fff&quot;);
      asm(&quot;and $sw, $sw, $7&quot;);
    }
    else if (int2) {
      printf(&quot;Harware interrupt 1\n&quot;);
      asm(&quot;lui $7, 0xfffe&quot;);
      asm(&quot;ori $7, $7, 0xffff&quot;);
      asm(&quot;and $sw, $sw, $7&quot;);
    }
    asm(&quot;lui $7, 0xffff&quot;);
    asm(&quot;ori $7, $7, 0xdfff&quot;);
    asm(&quot;and $sw, $sw, $7&quot;); // clear `I
  }
  asm(&quot;ori $sw, $sw, 0x200&quot;); // int enable
  RESTORE_REGISTERS;
  return;
}

void ISR() {
  asm(&quot;ISR:&quot;);
  asm(&quot;lui $at, 7&quot;);
  asm(&quot;ori $at, $at, 0xff00&quot;);
  asm(&quot;st $14, 48($at)&quot;);
  ISR_Handler();
  asm(&quot;lui $at, 7&quot;);
  asm(&quot;ori $at, $at, 0xff00&quot;);
  asm(&quot;ld $14, 48($at)&quot;);
  asm(&quot;c0mov $pc, $epc&quot;);
}

void int_sim() {
  asm(&quot;ori $sw, $sw, 0x200&quot;); // int enable
  asm(&quot;ori $sw, $sw, 0x2000&quot;); // set interrupt
  asm(&quot;ori $sw, $sw, 0x4000&quot;); // Software interrupt
  asm(&quot;ori $sw, $sw, 0x200&quot;); // int enable
  asm(&quot;ori $sw, $sw, 0x2000&quot;); // set interrupt
  asm(&quot;ori $sw, $sw, 0x8000&quot;); // hardware interrupt 0
  asm(&quot;ori $sw, $sw, 0x200&quot;); // int enable
  asm(&quot;ori $sw, $sw, 0x2000&quot;); // set interrupt
  asm(&quot;lui $at, 1&quot;);
  asm(&quot;or $sw, $sw, $at&quot;); // hardware interrupt 1
  return;
}
</pre></div>
</div>
<p class="rubric">exlbt/input/ch_lld_staticlink.h</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
<span class="c1">#include &quot;debug.h&quot;</span>
<span class="c1">#include &quot;print.h&quot;</span>

<span class="o">//</span><span class="c1">#define PRINT_TEST</span>

<span class="n">extern</span> <span class="s2">&quot;C&quot;</span> <span class="nb">int</span> <span class="n">printf</span><span class="p">(</span><span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="nb">format</span><span class="p">,</span> <span class="o">...</span><span class="p">);</span>
<span class="n">extern</span> <span class="s2">&quot;C&quot;</span> <span class="nb">int</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">char</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span> <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="nb">format</span><span class="p">,</span> <span class="o">...</span><span class="p">);</span>

<span class="n">extern</span> <span class="n">unsigned</span> <span class="n">char</span> <span class="n">sBuffer</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="n">extern</span> <span class="nb">int</span> <span class="n">test_overflow</span><span class="p">();</span>
<span class="n">extern</span> <span class="nb">int</span> <span class="n">test_add_overflow</span><span class="p">();</span>
<span class="n">extern</span> <span class="nb">int</span> <span class="n">test_sub_overflow</span><span class="p">();</span>
<span class="n">extern</span> <span class="nb">int</span> <span class="n">test_ctrl2</span><span class="p">();</span>
<span class="n">extern</span> <span class="nb">int</span> <span class="n">test_phinode</span><span class="p">(</span><span class="nb">int</span> <span class="n">a</span><span class="p">,</span> <span class="nb">int</span> <span class="n">b</span><span class="p">,</span> <span class="nb">int</span> <span class="n">c</span><span class="p">);</span>
<span class="n">extern</span> <span class="nb">int</span> <span class="n">test_blockaddress</span><span class="p">(</span><span class="nb">int</span> <span class="n">x</span><span class="p">);</span>
<span class="n">extern</span> <span class="nb">int</span> <span class="n">test_longbranch</span><span class="p">();</span>
<span class="n">extern</span> <span class="nb">int</span> <span class="n">test_func_arg_struct</span><span class="p">();</span>
<span class="n">extern</span> <span class="nb">int</span> <span class="n">test_tailcall</span><span class="p">(</span><span class="nb">int</span> <span class="n">a</span><span class="p">);</span>
<span class="n">extern</span> <span class="nb">bool</span> <span class="n">exceptionOccur</span><span class="p">;</span>
<span class="n">extern</span> <span class="nb">int</span> <span class="n">test_detect_exception</span><span class="p">(</span><span class="nb">bool</span> <span class="n">exception</span><span class="p">);</span>

<span class="n">extern</span> <span class="nb">int</span> <span class="n">test_staticlink</span><span class="p">();</span>
</pre></div>
</div>
<p class="rubric">exlbt/input/ch_lld_staticlink.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
#include &quot;ch4_1_addsuboverflow.cpp&quot;
#include &quot;ch8_1_br_jt.cpp&quot;
#include &quot;ch8_2_phinode.cpp&quot;
#include &quot;ch8_1_blockaddr.cpp&quot;
#include &quot;ch8_2_longbranch.cpp&quot;
#include &quot;ch9_2_tailcall.cpp&quot;
#include &quot;ch9_3_detect_exception.cpp&quot;

void test_printf() {
  char ptr[] = &quot;Hello world!&quot;;
  char *np = 0;
  int i = 5;
  unsigned int bs = sizeof(int)*8;
  int mi;
  char buf[80];

  mi = (1 &lt;&lt; (bs-1)) + 1;
  printf(&quot;%s\n&quot;, ptr);
  printf(&quot;printf test\n&quot;);
  printf(&quot;%s is null pointer\n&quot;, np);
  printf(&quot;%d = 5\n&quot;, i);
  printf(&quot;%d = - max int\n&quot;, mi);
  printf(&quot;char %c = &#39;a&#39;\n&quot;, &#39;a&#39;);
  printf(&quot;hex %x = ff\n&quot;, 0xff);
  printf(&quot;hex %02x = 00\n&quot;, 0);
  printf(&quot;signed %d = unsigned %u = hex %x\n&quot;, -3, -3, -3);
  printf(&quot;%d %s(s)&quot;, 0, &quot;message&quot;);
  printf(&quot;\n&quot;);
  printf(&quot;%d %s(s) with %%\n&quot;, 0, &quot;message&quot;);
  sprintf(buf, &quot;justif: \&quot;%-10s\&quot;\n&quot;, &quot;left&quot;); printf(&quot;%s&quot;, buf);
  sprintf(buf, &quot;justif: \&quot;%10s\&quot;\n&quot;, &quot;right&quot;); printf(&quot;%s&quot;, buf);
  sprintf(buf, &quot; 3: %04d zero padded\n&quot;, 3); printf(&quot;%s&quot;, buf);
  sprintf(buf, &quot; 3: %-4d left justif.\n&quot;, 3); printf(&quot;%s&quot;, buf);
  sprintf(buf, &quot; 3: %4d right justif.\n&quot;, 3); printf(&quot;%s&quot;, buf);
  sprintf(buf, &quot;-3: %04d zero padded\n&quot;, -3); printf(&quot;%s&quot;, buf);
  sprintf(buf, &quot;-3: %-4d left justif.\n&quot;, -3); printf(&quot;%s&quot;, buf);
  sprintf(buf, &quot;-3: %4d right justif.\n&quot;, -3); printf(&quot;%s&quot;, buf);
}

void verify_test_ctrl2()
{
  int a = -1;
  int b = -1;
  int c = -1;
  int d = -1;

  sBuffer[0] = (unsigned char)0x35;
  sBuffer[1] = (unsigned char)0x35;
  a = test_ctrl2();
  sBuffer[0] = (unsigned char)0x30;
  sBuffer[1] = (unsigned char)0x29;
  b = test_ctrl2();
  sBuffer[0] = (unsigned char)0x35;
  sBuffer[1] = (unsigned char)0x35;
  c = test_ctrl2();
  sBuffer[0] = (unsigned char)0x34;
  d = test_ctrl2();
  printf(&quot;test_ctrl2(): a = %d, b = %d, c = %d, d = %d&quot;, a, b, c, d);
  if (a == 1 &amp;&amp; b == 0 &amp;&amp; c == 1 &amp;&amp; d == 0)
    printf(&quot;, PASS\n&quot;);
  else
    printf(&quot;, FAIL\n&quot;);

  return;
}

int test_staticlink()
{
  int a = 0;

// pre-defined compiler macro (from llc -march=cpu0${ENDIAN} or 
// clang -target cpu0${ENDIAN}-unknown-linux-gnu
// http://beefchunk.com/documentation/lang/c/pre-defined-c/prearch.html 
#ifdef __CPU0EB__
  printf(&quot;__CPU0EB__\n&quot;);
#endif
#ifdef __CPU0EL__
  printf(&quot;__CPU0EL__\n&quot;);
#endif
  test_printf();
  a = test_add_overflow();
  a = test_sub_overflow();
  a = test_global();  // gI = 100
  printf(&quot;global variable gI = %d&quot;, a);
  if (a == 100)
    printf(&quot;, PASS\n&quot;);
  else
    printf(&quot;, FAIL\n&quot;);
  verify_test_ctrl2();
  a = test_phinode(3, 1, 0);
  printf(&quot;test_phinode(3, 1) = %d&quot;, a); // a = 3
  if (a == 3)
    printf(&quot;, PASS\n&quot;);
  else
    printf(&quot;, FAIL\n&quot;);
  a = test_blockaddress(1);
  printf(&quot;test_blockaddress(1) = %d&quot;, a); // a = 1
  if (a == 1)
    printf(&quot;, PASS\n&quot;);
  else
    printf(&quot;, FAIL\n&quot;);
  a = test_blockaddress(2);
  printf(&quot;test_blockaddress(2) = %d&quot;, a); // a = 2
  if (a == 2)
    printf(&quot;, PASS\n&quot;);
  else
    printf(&quot;, FAIL\n&quot;);
  a = test_longbranch();
  printf(&quot;test_longbranch() = %d&quot;, a); // a = 0
  if (a == 0)
    printf(&quot;, PASS\n&quot;);
  else
    printf(&quot;, FAIL\n&quot;);
  a = test_func_arg_struct();
  printf(&quot;test_func_arg_struct() = %d&quot;, a); // a = 0
  if (a == 0)
    printf(&quot;, PASS\n&quot;);
  else
    printf(&quot;, FAIL\n&quot;);
  a = test_constructor();
  printf(&quot;test_constructor() = %d&quot;, a); // a = 0
  if (a == 0)
    printf(&quot;, PASS\n&quot;);
  else
    printf(&quot;, FAIL\n&quot;);
  a = test_template();
  printf(&quot;test_template() = %d&quot;, a); // a = 15
  if (a == 15)
    printf(&quot;, PASS\n&quot;);
  else
    printf(&quot;, FAIL\n&quot;);
  long long res = test_template_ll();
  printf(&quot;test_template_ll() = 0x%X-%X&quot;, (int)(res&gt;&gt;32), (int)res); // res = -1
  if (res == -1)
    printf(&quot;, PASS\n&quot;);
  else
    printf(&quot;, FAIL\n&quot;);
  a = test_tailcall(5);
  printf(&quot;test_tailcall(5) = %d&quot;, a); // a = 15
  if (a == 120)
    printf(&quot;, PASS\n&quot;);
  else
    printf(&quot;, FAIL\n&quot;);
  test_detect_exception(true);
  printf(&quot;exceptionOccur= %d&quot;, exceptionOccur);
  if (exceptionOccur)
    printf(&quot;, PASS\n&quot;);
  else
    printf(&quot;, FAIL\n&quot;);
  test_detect_exception(false);
  printf(&quot;exceptionOccur= %d&quot;, exceptionOccur);
  if (!exceptionOccur)
    printf(&quot;, PASS\n&quot;);
  else
    printf(&quot;, FAIL\n&quot;);
  a = inlineasm_global(); // 4
  printf(&quot;inlineasm_global() = %d&quot;, a); // a = 4
  if (a == 4)
    printf(&quot;, PASS\n&quot;);
  else
    printf(&quot;, FAIL\n&quot;);
  a = test_cpp_polymorphism();
  printf(&quot;test_cpp_polymorphism() = %d&quot;, a); // a = 0
  if (a == 0)
    printf(&quot;, PASS\n&quot;);
  else
    printf(&quot;, FAIL\n&quot;);

  int_sim();

  return 0;
}

// test passing compilation only
#include &quot;builtins-cpu0.c&quot;
</pre></div>
</div>
<p class="rubric">exlbt/input/ch_slinker.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
<span class="c1">#include &quot;ch_nolld.h&quot;</span>
<span class="c1">#include &quot;ch_lld_staticlink.h&quot;</span>

<span class="nb">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nb">bool</span> <span class="k">pass</span> <span class="o">=</span> <span class="n">true</span><span class="p">;</span>
  <span class="k">pass</span> <span class="o">=</span> <span class="n">test_nolld</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">pass</span><span class="p">)</span>
    <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;test_nolld(): PASS</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;test_nolld(): FAIL</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">);</span>
  <span class="k">pass</span> <span class="o">=</span> <span class="n">true</span><span class="p">;</span>
  <span class="k">pass</span> <span class="o">=</span> <span class="n">test_staticlink</span><span class="p">();</span>

  <span class="k">return</span> <span class="k">pass</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">#include &quot;ch_nolld.cpp&quot;</span>
<span class="c1">#include &quot;ch_lld_staticlink.cpp&quot;</span>
</pre></div>
</div>
<p class="rubric">exlbt/input/Makefile.slinker</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
SRCS := start.cpp debug.cpp printf-stdarg-def.c printf-stdarg.c ch_slinker.cpp \
	lib_cpu0.c
INC_DIRS := $(SRC_DIR) $(LBDEX_DIR)/input
LIBBUILTINS_DIR :=
LIBS :=

include Common.mk
</pre></div>
</div>
<p class="rubric">exlbt/input/make.sh</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>#!/usr/bin/env bash

# for example:
# bash make.sh cpu032I eb Makefile.newlib
# bash make.sh cpu032II eb Makefile.builtins
# bash make.sh cpu032I el Makefile.slinker
# bash make.sh cpu032II eb Makefile.float
# bash make.sh cpu032II el Makefile.ch13_1

LBDEX_DIR=$HOME/git/lbd/lbdex
NEWLIB_DIR=$HOME/git/newlib-cygwin

ARG_NUM=$#
CPU=$1
ENDIAN=$2
MKFILE=$3

BUILD_DIR=build-$CPU-$ENDIAN

build_newlib() {
  pushd $NEWLIB_DIR
  rm -rf $BUILD_DIR
  mkdir $BUILD_DIR
  cd build
  CC=$TOOLDIR/clang \
  CFLAGS=&quot;-target cpu0$ENDIAN-unknown-linux-gnu -mcpu=$CPU -static \
          -fintegrated-as -Wno-error=implicit-function-declaration&quot; \
          AS=&quot;$TOOLDIR/clang -static -fintegrated-as -c&quot; \
          AR=&quot;$TOOLDIR/llvm-ar&quot; RANLIB=&quot;$TOOLDIR/llvm-ranlib&quot; \
          READELF=&quot;$TOOLDIR/llvm-readelf&quot; ../newlib/configure --host=cpu0
  make
  popd
}

prologue() {
  if [ $ARG_NUM == 0 ]; then
    echo &quot;useage: bash $sh_name cpu_type ENDIAN&quot;
    echo &quot;  cpu_type: cpu032I or cpu032II&quot;
    echo &quot;  ENDIAN: be (big ENDIAN, default) or le (little ENDIAN)&quot;
    echo &quot;for example:&quot;
    echo &quot;  bash build-slinker.sh cpu032I eb&quot;
    exit 1;
  fi
  if [ $CPU != cpu032I ] &amp;&amp; [ $CPU != cpu032II ]; then
    echo &quot;1st argument is cpu032I or cpu032II&quot;
    exit 1
  fi

  INCDIR=../../lbdex/input
  OS=`uname -s`
  echo &quot;OS =&quot; ${OS}

  TOOLDIR=~/llvm/test/build/bin
  CLANG=~/llvm/test/build/bin/clang

  echo &quot;CPU =&quot; &quot;${CPU}&quot;
  echo &quot;ENDIAN =&quot; &quot;${ENDIAN}&quot;

  if [ $ENDIAN != eb ] &amp;&amp; [ $ENDIAN != el ]; then
    echo &quot;2nd argument is be (big ENDIAN, default) or le (little ENDIAN)&quot;
    exit 1
  fi

  if [ $MKFILE == &quot;Makefile.newlib&quot; ] || [ $MKFILE == &quot;Makefile.builtins&quot; ]; then
    echo &quot;build_newlib&quot;
#    build_newlib;
  fi
  rm $BUILD_DIR/a.out
}

isLittleEndian() {
  echo &quot;ENDIAN = &quot; &quot;$ENDIAN&quot;
  if [ &quot;$ENDIAN&quot; == &quot;LittleEndian&quot; ] ; then
    le=&quot;true&quot;
  elif [ &quot;$ENDIAN&quot; == &quot;BigEndian&quot; ] ; then
    le=&quot;false&quot;
  else
    echo &quot;!ENDIAN unknown&quot;
    exit 1
  fi
}

elf2hex() {
  ${TOOLDIR}/elf2hex -le=${le} $BUILD_DIR/a.out &gt; ${LBDEX_DIR}/verilog/cpu0.hex
  if [ ${le} == &quot;true&quot; ] ; then
    echo &quot;1   /* 0: big ENDIAN, 1: little ENDIAN */&quot; &gt; ${LBDEX_DIR}/verilog/cpu0.config
  else
    echo &quot;0   /* 0: big ENDIAN, 1: little ENDIAN */&quot; &gt; ${LBDEX_DIR}/verilog/cpu0.config
  fi
  cat ${LBDEX_DIR}/verilog/cpu0.config
}

epilogue() {
  ENDIAN=`${TOOLDIR}/llvm-readobj -h $BUILD_DIR/a.out|grep &quot;DataEncoding&quot;|awk &#39;{print $2}&#39;`
  isLittleEndian;
  elf2hex;
}

FILE=$3

if [ ! -f &quot;$FILE&quot; ]; then
  echo &quot;$FILE does not exists.&quot;
  exit 0;
fi

prologue;

make -f $FILE CPU=${CPU} ENDIAN=${ENDIAN} LBDEX_DIR=${LBDEX_DIR} NEWLIB_DIR=${NEWLIB_DIR}

epilogue;

</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">1-160-136-173:input Jonathan$ </span><span class="nb">pwd</span>
<span class="go">/Users/Jonathan/Downloads/exlbt/input</span>
<span class="gp">114-37-148-111:input Jonathan$ </span>bash make.sh cpu032I le Makefile.slinker
<span class="go">...</span>
<span class="go">endian =  LittleEndian</span>
<span class="go">ISR address:00020780</span>
<span class="go">1   /* 0: big endian, 1: little endian */</span>
<span class="gp">chungshu@ChungShudeMacBook-Air verilog % </span>./cpu0Is
<span class="go">WARNING: cpu0.v:487: $readmemh(cpu0.hex): Not enough words in the file for the requested range [0:524287].</span>
<span class="go">taskInterrupt(001)</span>
<span class="go">74</span>
<span class="go">7</span>
<span class="go">0</span>
<span class="go">0</span>
<span class="go">253</span>
<span class="go">3</span>
<span class="go">1</span>
<span class="go">13</span>
<span class="go">3</span>
<span class="go">-126</span>
<span class="go">130</span>
<span class="go">-32766</span>
<span class="go">32770</span>
<span class="go">393307</span>
<span class="go">16777222</span>
<span class="go">-3</span>
<span class="go">-4</span>
<span class="go">51</span>
<span class="go">2</span>
<span class="go">3</span>
<span class="go">1</span>
<span class="go">2147483647</span>
<span class="go">-2147483648</span>
<span class="go">9</span>
<span class="go">12</span>
<span class="go">5</span>
<span class="go">0</span>
<span class="go">31</span>
<span class="go">49</span>
<span class="go">test_nolld(): PASS</span>
<span class="go">__CPU0EL__</span>
<span class="go">Hello world!</span>
<span class="go">printf test</span>
<span class="gp gp-VirtualEnv">(null)</span> <span class="go">is null pointer</span>
<span class="go">5 = 5</span>
<span class="go">-2147483647 = - max int</span>
<span class="go">char a = &#39;a&#39;</span>
<span class="go">hex ff = ff</span>
<span class="go">hex 00 = 00</span>
<span class="go">signed -3 = unsigned 4294967293 = hex fffffffd</span>
<span class="go">0 message(s)</span>
<span class="go">0 message(s) with %</span>
<span class="go">justif: &quot;left      &quot;</span>
<span class="go">justif: &quot;     right&quot;</span>
<span class="go"> 3: 0003 zero padded</span>
<span class="go"> 3: 3    left justif.</span>
<span class="go"> 3:    3 right justif.</span>
<span class="go">-3: -003 zero padded</span>
<span class="go">-3: -3   left justif.</span>
<span class="go">-3:   -3 right justif.</span>
<span class="go">global variable gI = 100, PASS</span>
<span class="go">test_ctrl2(): a = 1, b = 0, c = 1, d = 0, PASS</span>
<span class="go">test_phinode(3, 1) = 3, PASS</span>
<span class="go">test_blockaddress(1) = 1, PASS</span>
<span class="go">test_blockaddress(2) = 2, PASS</span>
<span class="go">test_longbranch() = 0, PASS</span>
<span class="go">test_func_arg_struct() = 0, PASS</span>
<span class="go">test_constructor() = 0, PASS</span>
<span class="go">test_template() = 15, PASS</span>
<span class="go">test_template_ll() = 0xFFFFFFFF-FFFFFFFF, PASS</span>
<span class="go">test_tailcall(5) = 120, PASS</span>
<span class="go">exceptionOccur= 1, PASS</span>
<span class="go">exceptionOccur= 0, PASS</span>
<span class="go">inlineasm_global() = 4, PASS</span>
<span class="go">20</span>
<span class="go">10</span>
<span class="go">5</span>
<span class="go">test_cpp_polymorphism() = 0, PASS</span>
<span class="go">taskInterrupt(011)</span>
<span class="go">Software interrupt</span>
<span class="go">taskInterrupt(011)</span>
<span class="go">Harware interrupt 0</span>
<span class="go">taskInterrupt(011)</span>
<span class="go">Harware interrupt 1</span>
<span class="go">...</span>
<span class="go">RET to PC &lt; 0, finished!</span>
</pre></div>
</div>
<p>Above test includes the printf format verification.
Let’s check the result with PC program printf-stdarg-1.c output as follows,</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">1-160-136-173:input Jonathan$ </span>clang printf-stdarg-1.c
<span class="go">printf-stdarg-1.c:58:19: warning: incomplete format specifier [-Wformat]</span>
<span class="go">  printf(&quot;%d %s(s)%&quot;, 0, &quot;message&quot;);</span>
<span class="go">                  ^</span>
<span class="go">1 warning generated.</span>
<span class="gp">1-160-136-173:input Jonathan$ </span>./a.out
<span class="go">Hello world!</span>
<span class="go">printf test</span>
<span class="gp gp-VirtualEnv">(null)</span> <span class="go">is null pointer</span>
<span class="go">5 = 5</span>
<span class="go">-2147483647 = - max int</span>
<span class="go">char a = &#39;a&#39;</span>
<span class="go">hex ff = ff</span>
<span class="go">hex 00 = 00</span>
<span class="go">signed -3 = unsigned 4294967293 = hex fffffffd</span>
<span class="go">0 message(s)</span>
<span class="go">0 message(s) with \%</span>
<span class="go">justif: &quot;left      &quot;</span>
<span class="go">justif: &quot;     right&quot;</span>
<span class="go"> 3: 0003 zero padded</span>
<span class="go"> 3: 3    left justif.</span>
<span class="go"> 3:    3 right justif.</span>
<span class="go">-3: -003 zero padded</span>
<span class="go">-3: -3   left justif.</span>
<span class="go">-3:   -3 right justif.</span>
</pre></div>
</div>
<p>As above, by taking the open source code advantage, Cpu0 got the more stable
printf() program.
Once Cpu0 backend can translate the printf() function of the open source C
printf() program into machine instructions, the llvm Cpu0 backend can be
verified with printf().
With the quality code of open source printf() program, the Cpu0 toolchain is
extended from compiler backend to C std library support. (Notice that some GPL
open source code are not quality code, but some are.)</p>
<p>The “Overflow exception is printed twice meaning the ISR() of debug.cpp is
called twice from ch4_1_2.cpp.
The printed “taskInterrupt(001)” and “taskInterrupt(011)” just are trace
message from cpu0.v code.</p>
</section>
<section id="dynamic-linker">
<h3><a class="toc-backref" href="#id21">Dynamic linker</a><a class="headerlink" href="#dynamic-linker" title="Permalink to this headline">¶</a></h3>
<p>I remove dynamic linker demostration from 3.9.0 because I don’t know how to
do it from lld 3.9 and this demostration add lots of code in elf2hex, verilog
and lld of Cpu0 backend. However it can be run with llvm 3.7 with the following
command.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">1-160-136-173:test Jonathan$ </span><span class="nb">pwd</span>
<span class="go">/Users/Jonathan/test</span>
<span class="gp">1-160-136-173:test Jonathan$ </span>git clone https://github.com/Jonathan2251/lbd
<span class="gp">1-160-136-173:test Jonathan$ </span>git clone https://github.com/Jonathan2251/lbt
<span class="gp">1-160-136-173:test Jonathan$ </span><span class="nb">cd</span> lbd
<span class="gp">1-160-136-173:lbd Jonathan$ </span><span class="nb">pwd</span>
<span class="go">/Users/Jonathan/test/lbd</span>
<span class="gp">1-160-136-173:lbd Jonathan$ </span>git checkout release_374
<span class="gp">1-160-136-173:lbd Jonathan$ </span><span class="nb">cd</span> ../lbt
<span class="gp">1-160-136-173:test Jonathan$ </span>git checkout release_374
<span class="gp">1-160-136-173:lbt Jonathan$ </span>make html
</pre></div>
</div>
<p>Then reading this section in lld.html for it.</p>
</section>
</section>
<section id="summary">
<h2><a class="toc-backref" href="#id22">Summary</a><a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h2>
<section id="create-a-new-backend-base-on-llvm">
<h3><a class="toc-backref" href="#id23">Create a new backend base on LLVM</a><a class="headerlink" href="#create-a-new-backend-base-on-llvm" title="Permalink to this headline">¶</a></h3>
<p>Thanks the llvm open source project.
To write a linker and ELF to Hex tools for a new CPU architecture is easy and
reliable.
Combined with the llvm Cpu0 backend code and Verilog language code programmed
in previouse chapters, we design a software
toolchain to compile C/C++ code, link and run it on Verilog Cpu0 simulator
without any real hardware investment.
If you buy the FPGA development hardware, we believe these
code can run on FPGA CPU even though we didn’t do it.
Extend system program toolchain to support a new CPU instruction set can be
finished just like we have shown you at this point.
School knowledges of system program, compiler, linker, loader, computer
architecture and CPU design has been translated into a real work and see how it
is running. Now, these school books knowledge is not limited on paper.
We design it, program it, and run it on real world.</p>
<p>The total code size of llvm Cpu0 backend compiler, Cpu0 lld linker, elf2hex and
Cpu0 Verilog Language is around 10 thousands lines of source code include
comments.
The total code size of clang, llvm and lld has 1000 thousands lines exclude the
test and documents parts. It is only 1 % of the llvm size.
More over, the llvm Cpu0 backend and lld Cpu0 backend are 70% of same with llvm
Mips and lld X86_64.
Based on this truth, we believe llvm is a well defined structure in compiler
architecture.</p>
</section>
<section id="contribute-back-to-open-source-through-working-and-learning">
<h3><a class="toc-backref" href="#id24">Contribute back to Open Source through working and learning</a><a class="headerlink" href="#contribute-back-to-open-source-through-working-and-learning" title="Permalink to this headline">¶</a></h3>
<p>Finally, 10 thousands lines of source code in Cpu0 backend is very small in UI
program. But it’s quite complex in system program which based on llvm.
We spent 600 pages of pdf to explain these code. Open source code give
programmers best opportunity to understand the code and enhance/extend the
code function. But it can be better, we believe the documentation is the next
most important thing to improve the open source code development.
The Open Source Organization recognized this point and set
Open Source Document Project years ago <a class="footnote-reference brackets" href="#bsdlicense" id="id4">8</a> <a class="footnote-reference brackets" href="#docproj" id="id5">9</a>
<a class="footnote-reference brackets" href="#freebsdlicense" id="id6">10</a> <a class="footnote-reference brackets" href="#gnulicense" id="id7">11</a> <a class="footnote-reference brackets" href="#fdl" id="id8">12</a>.
Open Source grows up and becomes a giant software infrastructure with the forces
of company <a class="footnote-reference brackets" href="#apple-opensource" id="id9">13</a>  <a class="footnote-reference brackets" href="#ibm-opensource" id="id10">14</a>, school research team and
countless talent engineers passion.
It terminated the situation of everyone trying to re-invent wheels during 10
years ago.
Extend your software from the re-usable source code is the right way.
Of course you should consider an open source license if you are working
with business.
Actually anyone can contribute back to open source through the learning process.
This book is written through the process of learning llvm backend and contribute
back to llvm open source project.
We think this book cannot exists in traditional paper book form since only
few number of readers interested in study llvm backend even though
there are many paper published books in concept of compiler. So, this book
is published via electric media form and try to match the Open Document License
Expection <a class="footnote-reference brackets" href="#gnu-phi" id="id11">15</a>.
There are distance between the concept and the realistic program implemenation.
Keep note through learning a large complicate software such as this llvm backend
is not enough.
We all learned the knowledge through books during school and after school.
So, if you cannot find a good way to produce documents, you can consider to
write documents like this book. This book document uses sphinx tool
just like the llvm development team. Sphinx uses restructured text format here
<a class="footnote-reference brackets" href="#rst-ref" id="id12">16</a> <a class="footnote-reference brackets" href="#rst-directives" id="id13">17</a> <a class="footnote-reference brackets" href="#rst" id="id14">18</a>.
Appendix A of lbd book tell you how to install sphinx tool.
Documentation work will help yourself to re-examine your software and make your
program better in structure, reliability and more important “Extend your code
to somewhere you didn’t expect”.</p>
<dl class="footnote brackets">
<dt class="label" id="lldweb"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p><a class="reference external" href="http://lld.llvm.org/">http://lld.llvm.org/</a></p>
</dd>
<dt class="label" id="lld-install"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p><a class="reference external" href="http://lld.llvm.org/getting_started.html#on-unix-like-systems">http://lld.llvm.org/getting_started.html#on-unix-like-systems</a></p>
</dd>
<dt class="label" id="llvm-download"><span class="brackets">3</span></dt>
<dd><p><a class="reference external" href="http://llvm.org/releases/download.html#3.5">http://llvm.org/releases/download.html#3.5</a></p>
</dd>
</dl>
<dl class="footnote brackets">
<dt class="label" id="get"><span class="brackets">4</span></dt>
<dd><p><a class="reference external" href="http://www.cplusplus.com/reference/memory/unique_ptr/get/">http://www.cplusplus.com/reference/memory/unique_ptr/get/</a></p>
</dd>
<dt class="label" id="move"><span class="brackets">5</span></dt>
<dd><p><a class="reference external" href="http://www.cplusplus.com/reference/utility/move/">http://www.cplusplus.com/reference/utility/move/</a></p>
</dd>
<dt class="label" id="pic-call-stub"><span class="brackets">6</span></dt>
<dd><p>Page 5-12 of <a class="reference external" href="http://www.linux-mips.org/pub/linux/mips/doc/ABI/mipsabi.pdf">http://www.linux-mips.org/pub/linux/mips/doc/ABI/mipsabi.pdf</a></p>
</dd>
<dt class="label" id="printf-stdarg"><span class="brackets"><a class="fn-backref" href="#id3">7</a></span></dt>
<dd><p><a class="reference external" href="https://github.com/atgreen/FreeRTOS/blob/master/Demo/CORTEX_STM32F103_Primer_GCC/printf-stdarg.c">https://github.com/atgreen/FreeRTOS/blob/master/Demo/CORTEX_STM32F103_Primer_GCC/printf-stdarg.c</a></p>
</dd>
<dt class="label" id="bsdlicense"><span class="brackets"><a class="fn-backref" href="#id4">8</a></span></dt>
<dd><p><a class="reference external" href="http://en.wikipedia.org/wiki/BSD_Documentation_License">http://en.wikipedia.org/wiki/BSD_Documentation_License</a></p>
</dd>
<dt class="label" id="docproj"><span class="brackets"><a class="fn-backref" href="#id5">9</a></span></dt>
<dd><p><a class="reference external" href="http://www.freebsd.org/docproj/">http://www.freebsd.org/docproj/</a></p>
</dd>
<dt class="label" id="freebsdlicense"><span class="brackets"><a class="fn-backref" href="#id6">10</a></span></dt>
<dd><p><a class="reference external" href="http://www.freebsd.org/copyright/freebsd-doc-license.html">http://www.freebsd.org/copyright/freebsd-doc-license.html</a></p>
</dd>
<dt class="label" id="gnulicense"><span class="brackets"><a class="fn-backref" href="#id7">11</a></span></dt>
<dd><p><a class="reference external" href="http://en.wikipedia.org/wiki/GNU_Free_Documentation_License">http://en.wikipedia.org/wiki/GNU_Free_Documentation_License</a></p>
</dd>
<dt class="label" id="fdl"><span class="brackets"><a class="fn-backref" href="#id8">12</a></span></dt>
<dd><p><a class="reference external" href="http://www.gnu.org/copyleft/fdl.html">http://www.gnu.org/copyleft/fdl.html</a></p>
</dd>
<dt class="label" id="apple-opensource"><span class="brackets"><a class="fn-backref" href="#id9">13</a></span></dt>
<dd><p><a class="reference external" href="http://www.apple.com/opensource/">http://www.apple.com/opensource/</a></p>
</dd>
<dt class="label" id="ibm-opensource"><span class="brackets"><a class="fn-backref" href="#id10">14</a></span></dt>
<dd><p><a class="reference external" href="https://www.ibm.com/developerworks/opensource/">https://www.ibm.com/developerworks/opensource/</a></p>
</dd>
<dt class="label" id="gnu-phi"><span class="brackets"><a class="fn-backref" href="#id11">15</a></span></dt>
<dd><p><a class="reference external" href="http://www.gnu.org/philosophy/free-doc.en.html">http://www.gnu.org/philosophy/free-doc.en.html</a></p>
</dd>
<dt class="label" id="rst-ref"><span class="brackets"><a class="fn-backref" href="#id12">16</a></span></dt>
<dd><p><a class="reference external" href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html</a></p>
</dd>
<dt class="label" id="rst-directives"><span class="brackets"><a class="fn-backref" href="#id13">17</a></span></dt>
<dd><p><a class="reference external" href="http://docutils.sourceforge.net/docs/ref/rst/directives.html">http://docutils.sourceforge.net/docs/ref/rst/directives.html</a></p>
</dd>
<dt class="label" id="rst"><span class="brackets"><a class="fn-backref" href="#id14">18</a></span></dt>
<dd><p><a class="reference external" href="http://docutils.sourceforge.net/rst.html">http://docutils.sourceforge.net/rst.html</a></p>
</dd>
</dl>
</section>
</section>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="clang.html">Clang</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="opt.html">Optimization</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Chen Chung-Shu.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.4.0.
    </div>
  </body>
</html>