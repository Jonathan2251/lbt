
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Optimization &#8212; Tutorial: Creating an LLVM Toolchain for the Cpu0 Architecture</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/haiku.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Library" href="lib.html" />
    <link rel="prev" title="Cpu0 ELF linker" href="lld.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>Tutorial: Creating an LLVM Toolchain for the Cpu0 Architecture</span></a></h1>
        <h2 class="heading"><span>Optimization</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="lld.html">Cpu0 ELF linker</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="lib.html">Library</a>&#160;&#160;»
        </p>

      </div>
      <div class="content" role="main">
        
        
  <section id="optimization">
<span id="sec-opt"></span><h1>Optimization<a class="headerlink" href="#optimization" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#llvm-ir-optimization" id="id6">LLVM IR optimization</a></p></li>
<li><p><a class="reference internal" href="#project" id="id7">Project</a></p>
<ul>
<li><p><a class="reference internal" href="#llvm-vpo" id="id8">LLVM-VPO</a></p></li>
</ul>
</li>
</ul>
</div>
<p>This chapter introduce llvm optimization.</p>
<section id="llvm-ir-optimization">
<h2><a class="toc-backref" href="#id6">LLVM IR optimization</a><a class="headerlink" href="#llvm-ir-optimization" title="Permalink to this headline">¶</a></h2>
<p>The llvm-link provide optimizaton in IR level which can apply in different
programs developed by more than one language. Of course, it can apply in
the same language which support seperate compile.</p>
<figure class="align-center" id="id5">
<span id="llvm-link-f-flow"></span><a class="reference internal image-reference" href="_images/11.png"><img alt="_images/11.png" src="_images/11.png" style="width: 821.0px; height: 258.0px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 4 </span><span class="caption-text">llvm-link flow</span><a class="headerlink" href="#id5" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>Clang provide optimization options to do optimation from high level language
to IR.
But since many languages like C/C++ support separate compilation, it meaning
there is no chance to do inter-procedure optimization if the functions come from
different source files.
To solve this problem, llvm provide <strong>llvm-link</strong> to link all *.bc into a single
IR file, and through <strong>opt</strong> to finish the inter-procedure optimation <a class="footnote-reference brackets" href="#id4" id="id1">1</a>.
Beyond the DAG local optimization mentioned in Chapter 2, there are global
optimization based on inter-procedure analysis <a class="footnote-reference brackets" href="#dragonbooks-9" id="id2">2</a>.
The following steps and examples show this optimization solution in llvm.</p>
<p class="rubric">exlbt/input/optimizen/1.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">callee</span><span class="p">(</span><span class="n">const</span> <span class="nb">int</span> <span class="o">*</span><span class="n">a</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">*</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

</pre></div>
</div>
<p class="rubric">exlbt/input/optimize/2.cpp</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">extern</span> <span class="nb">int</span> <span class="n">callee</span><span class="p">(</span><span class="n">const</span> <span class="nb">int</span> <span class="o">*</span><span class="n">X</span><span class="p">);</span>

<span class="nb">int</span> <span class="n">caller</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">int</span> <span class="n">T</span><span class="p">;</span>

  <span class="n">T</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">callee</span><span class="p">(</span><span class="o">&amp;</span><span class="n">T</span><span class="p">);</span>
<span class="p">}</span>

</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:input Jonathan$ </span>clang -O3 -target mips-unknown-linux-gnu
<span class="go">-c 1.cpp -emit-llvm -o 1.bc</span>
<span class="gp">JonathantekiiMac:input Jonathan$ </span>clang -O3 -target mips-unknown-linux-gnu
<span class="go">-c 2.cpp -emit-llvm -o 2.bc</span>
<span class="gp">JonathantekiiMac:input Jonathan$ </span>llvm-link -o<span class="o">=</span>a.bc <span class="m">1</span>.bc <span class="m">2</span>.bc
<span class="gp">JonathantekiiMac:input Jonathan$ </span>opt -O3 -o<span class="o">=</span>a1.bc a.bc
<span class="gp">JonathantekiiMac:input Jonathan$ </span>llvm-dis a.bc -o -
<span class="go">...</span>
<span class="go">; Function Attrs: nounwind readonly</span>
<span class="go">define i32 @_Z6calleePKi(i32* nocapture readonly %a) #0 {</span>
<span class="gp">  %</span><span class="nv">1</span> <span class="o">=</span> load i32* %a, align <span class="m">4</span>, !tbaa !1
<span class="gp">  %</span><span class="nv">2</span> <span class="o">=</span> add nsw i32 %1, <span class="m">1</span>
<span class="go">  ret i32 %2</span>
<span class="go">}</span>

<span class="go">define i32 @_Z6callerv() #1 {</span>
<span class="gp">  %</span><span class="nv">T</span> <span class="o">=</span> alloca i32, align <span class="m">4</span>
<span class="go">  store i32 4, i32* %T, align 4, !tbaa !1</span>
<span class="gp">  %</span><span class="nv">1</span> <span class="o">=</span> call i32 @_Z6calleePKi<span class="o">(</span>i32* %T<span class="o">)</span>
<span class="go">  ret i32 %1</span>
<span class="go">}</span>
<span class="go">...</span>

<span class="gp">JonathantekiiMac:input Jonathan$ </span>llvm-dis a1.bc -o -
<span class="go">...</span>
<span class="go">; Function Attrs: nounwind readonly</span>
<span class="go">define i32 @_Z6calleePKi(i32* nocapture readonly %a) #0 {</span>
<span class="gp">  %</span><span class="nv">1</span> <span class="o">=</span> load i32* %a, align <span class="m">4</span>, !tbaa !1
<span class="gp">  %</span><span class="nv">2</span> <span class="o">=</span> add nsw i32 %1, <span class="m">1</span>
<span class="go">  ret i32 %2</span>
<span class="go">}</span>

<span class="go">; Function Attrs: nounwind readnone</span>
<span class="go">define i32 @_Z6callerv() #1 {</span>
<span class="go">  ret i32 5</span>
<span class="go">}</span>
<span class="go">...</span>
</pre></div>
</div>
<p>From the result as above, the <strong>opt</strong> output has lesser number of IR
instructions.
Of course, the backend code will be more effective as follows,</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">JonathantekiiMac:input Jonathan$ </span>~/llvm/test/build/
<span class="go">bin/llc -march=cpu0 -relocation-model=pic -filetype=asm a.bc -o -</span>
<span class="go">        .section .mdebug.abi32</span>
<span class="go">        .previous</span>
<span class="go">        .file &quot;a.bc&quot;</span>
<span class="go">        .text</span>
<span class="go">        .globl        _Z6calleePKi</span>
<span class="go">        .align        2</span>
<span class="go">        .type _Z6calleePKi,@function</span>
<span class="go">        .ent  _Z6calleePKi            # @_Z6calleePKi</span>
<span class="go">_Z6calleePKi:</span>
<span class="go">        .frame        $sp,0,$lr</span>
<span class="go">        .mask         0x00000000,0</span>
<span class="go">        .set  noreorder</span>
<span class="go">        .set  nomacro</span>
<span class="gp"># </span>BB#0:
<span class="go">        ld    $2, 0($sp)</span>
<span class="go">        ld    $2, 0($2)</span>
<span class="go">        addiu $2, $2, 1</span>
<span class="go">        ret   $lr</span>
<span class="go">        .set  macro</span>
<span class="go">        .set  reorder</span>
<span class="go">        .end  _Z6calleePKi</span>
<span class="gp">$</span>tmp0:
<span class="go">        .size _Z6calleePKi, ($tmp0)-_Z6calleePKi</span>

<span class="go">        .globl        _Z6callerv</span>
<span class="go">        .align        2</span>
<span class="go">        .type _Z6callerv,@function</span>
<span class="go">        .ent  _Z6callerv              # @_Z6callerv</span>
<span class="go">_Z6callerv:</span>
<span class="go">        .cfi_startproc</span>
<span class="go">        .frame        $sp,32,$lr</span>
<span class="go">        .mask         0x00004000,-4</span>
<span class="go">        .set  noreorder</span>
<span class="go">        .cpload       $t9</span>
<span class="go">        .set  nomacro</span>
<span class="gp"># </span>BB#0:
<span class="go">        addiu $sp, $sp, -32</span>
<span class="gp">$</span>tmp3:
<span class="go">        .cfi_def_cfa_offset 32</span>
<span class="go">        st    $lr, 28($sp)            # 4-byte Folded Spill</span>
<span class="gp">$</span>tmp4:
<span class="go">        .cfi_offset 14, -4</span>
<span class="go">        .cprestore    8</span>
<span class="go">        addiu $2, $zero, 4</span>
<span class="go">        st    $2, 24($sp)</span>
<span class="go">        addiu $2, $sp, 24</span>
<span class="go">        st    $2, 0($sp)</span>
<span class="go">        ld    $t9, %call16(_Z6calleePKi)($gp)</span>
<span class="go">        jalr  $t9</span>
<span class="go">        ld    $gp, 8($sp)</span>
<span class="go">        ld    $lr, 28($sp)            # 4-byte Folded Reload</span>
<span class="go">        addiu $sp, $sp, 32</span>
<span class="go">        ret   $lr</span>
<span class="go">        .set  macro</span>
<span class="go">        .set  reorder</span>
<span class="go">        .end  _Z6callerv</span>
<span class="gp">$</span>tmp5:
<span class="go">        .size _Z6callerv, ($tmp5)-_Z6callerv</span>
<span class="go">        .cfi_endproc</span>

<span class="gp">JonathantekiiMac:input Jonathan$ </span>~/llvm/test/build/
<span class="go">bin/llc -march=cpu0 -relocation-model=pic -filetype=asm a1.bc -o -</span>
<span class="go">        .section .mdebug.abi32</span>
<span class="go">        .previous</span>
<span class="go">        .file &quot;a1.bc&quot;</span>
<span class="go">        .text</span>
<span class="go">        .globl        _Z6calleePKi</span>
<span class="go">        .align        2</span>
<span class="go">        .type _Z6calleePKi,@function</span>
<span class="go">        .ent  _Z6calleePKi            # @_Z6calleePKi</span>
<span class="go">_Z6calleePKi:</span>
<span class="go">        .frame        $sp,0,$lr</span>
<span class="go">        .mask         0x00000000,0</span>
<span class="go">        .set  noreorder</span>
<span class="go">        .set  nomacro</span>
<span class="gp"># </span>BB#0:
<span class="go">        ld    $2, 0($sp)</span>
<span class="go">        ld    $2, 0($2)</span>
<span class="go">        addiu $2, $2, 1</span>
<span class="go">        ret   $lr</span>
<span class="go">        .set  macro</span>
<span class="go">        .set  reorder</span>
<span class="go">        .end  _Z6calleePKi</span>
<span class="gp">$</span>tmp0:
<span class="go">        .size _Z6calleePKi, ($tmp0)-_Z6calleePKi</span>

<span class="go">        .globl        _Z6callerv</span>
<span class="go">        .align        2</span>
<span class="go">        .type _Z6callerv,@function</span>
<span class="go">        .ent  _Z6callerv              # @_Z6callerv</span>
<span class="go">_Z6callerv:</span>
<span class="go">        .frame        $sp,0,$lr</span>
<span class="go">        .mask         0x00000000,0</span>
<span class="go">        .set  noreorder</span>
<span class="go">        .set  nomacro</span>
<span class="gp"># </span>BB#0:
<span class="go">        addiu $2, $zero, 5</span>
<span class="go">        ret   $lr</span>
<span class="go">        .set  macro</span>
<span class="go">        .set  reorder</span>
<span class="go">        .end  _Z6callerv</span>
<span class="gp">$</span>tmp1:
<span class="go">        .size _Z6callerv, ($tmp1)-_Z6callerv</span>
</pre></div>
</div>
<p>Though llvm-link provide optimization in IR level to support seperate compile,
it come with the cost in compile time. As you can imagine, any one statement
change will change the output IR of llvm-link. And the obj binary code have to
re-compile. Compare to the seperate compile for each *.c file, it only need to
re-compile the corresponding *.o file only.</p>
</section>
<section id="project">
<h2><a class="toc-backref" href="#id7">Project</a><a class="headerlink" href="#project" title="Permalink to this headline">¶</a></h2>
<section id="llvm-vpo">
<h3><a class="toc-backref" href="#id8">LLVM-VPO</a><a class="headerlink" href="#llvm-vpo" title="Permalink to this headline">¶</a></h3>
<p>Friend Gang-Ryung Uh replace LLC compiler by llvm on Very Portable Optimizer
(VPO) compiler toolchain. VPO performs optimizations on a single intermediate
representation called Register Transfer Lists (RTLs). In other word, the system
generate RTLs from llvm IR and it do further optimization on RTLs.</p>
<p>The LLVM-VPO is illustrated at his home page. Click <strong>“6. LLVM-VPO Compiler
Development - 2012 Google Faculty Research Award”</strong> at this home page
<a class="footnote-reference brackets" href="#gang-ryung" id="id3">3</a> will get the information.</p>
<dl class="footnote brackets">
<dt class="label" id="id4"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p><a class="reference external" href="http://www.cs.cmu.edu/afs/cs/academic/class/15745-s12/public/lectures/L3-LLVM-Part1.pdf">http://www.cs.cmu.edu/afs/cs/academic/class/15745-s12/public/lectures/L3-LLVM-Part1.pdf</a></p>
</dd>
<dt class="label" id="dragonbooks-9"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>Refer chapter 9 of book Compilers: Principles,
Techniques, and Tools (2nd Edition)</p>
</dd>
<dt class="label" id="gang-ryung"><span class="brackets"><a class="fn-backref" href="#id3">3</a></span></dt>
<dd><p><a class="reference external" href="http://cs.boisestate.edu/~uh/">http://cs.boisestate.edu/~uh/</a></p>
</dd>
</dl>
</section>
</section>
</section>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="lld.html">Cpu0 ELF linker</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="lib.html">Library</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Chen Chung-Shu.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.0.2.
    </div>
  </body>
</html>